<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solution -「CF 1491H」Yuezheng Ling and Dynamic Tree | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Solution -「CF 1491H」Yuezheng Ling and Dynamic Tree</h1><p><del>所以 Chinese Round 出 DS 是传统了对吧。</del></p>
<h2>Description</h2>
<p><a href="https://www.luogu.com.cn/problem/CF1491H">Link</a>.</p>
<p>Given is a rooted tree with the $\sf1$-th node as the root.</p>
<p>The tree will be given in this way: it will tell you that the parent of the $\sf i$-th node is $a_{i}$.</p>
<p>Supporting the following operations:</p>
<ul>
<li><code>1 l r x</code>: let $\sf \forall i\in[l,r],a_{i}=max{a_{i}-x,1}$.</li>
<li><code>2 u v</code>: find the LCA (Lowest Common Ancestor) of $\sf u$ and $\sf v$.</li>
</ul>
<h2>Solution</h2>
<p><img src="http://codeforces.com/predownloaded/ff/89/ff8966699d3f169f29b1e05c06b36e1c3ab67a91.png" alt=""></p>
<p>经典永流传。</p>
<p>考虑到修改操作是对结点进行的操作，然后这个东西不太能直接 LCT 或树剖，考虑照序列来分块，那么我们来对结点编号分块。</p>
<ol>
<li>修改；</li>
</ol>
<p>$\quad$维护一个属性 $\sf top_{u}$ 表示在原树上结点 $\sf u$ 的祖先中不和 $\sf u$ 在同一个块里面的编号最大的一个结点的编号，如果不存在的话就令 $\sf top_{u}=1$。这样的话你从结点 $\sf u$ 跳到 root 的复杂度为 $\sf O(\sqrt{n})$。接下来考虑怎么维护这个东西。</p>
<p>$\quad$散块我们直接暴力扫着改；对于整块，可以发现如果一个块的被修改次数超过了块的大小，那么就一定会有 $\sf top_{u}=fa_{u}$。</p>
<ol start="2">
<li>询问。</li>
</ol>
<p>$\quad$分三个类讨论，这个比较好做（差不多和树剖找 LCA 一个样子）。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,top[100010],deln[320],tag[320],belong[100010],bl[320],br[320],fa[100010],bs;
#define gtlf(x) ((x-1)*bs+1)
#define gtrg(x) (min(x*bs,n))
void updtop(int x)
{
	if(belong[x]^belong[fa[x]])	top[x]=fa[x];
	else	top[x]=top[fa[x]];
}
void turndown(int x)
{
	if(tag[x])
	{
		for(int i=gtlf(x);i&lt;=gtrg(x);++i)	fa[i]=max(fa[i]-tag[x],1);
		tag[x]=0;
	}
}
int main()
{
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m),bs=sqrt(double(n))+1,fa[1]=belong[1]=1;
	for(int i=2;i&lt;=n;++i)	scanf(&quot;%d&quot;,&amp;fa[i]);
	for(int i=2;i&lt;=n;++i)	belong[i]=(i-1)/bs+1,updtop(i);
	while(m--)
	{
		int opt; scanf(&quot;%d&quot;,&amp;opt);
		if(opt==1)
		{
			int opl,opr,opx;
			scanf(&quot;%d %d %d&quot;,&amp;opl,&amp;opr,&amp;opx);
			turndown(belong[opl]);
			if(belong[opl]==belong[opr])
			{
				turndown(belong[opl]);
				for(int i=opl;i&lt;=opr;++i)	fa[i]=max(fa[i]-opx,1),updtop(i);
				for(int i=opr+1;i&lt;=gtrg(belong[opl]);++i)	updtop(i);
			}
			else
			{
				turndown(belong[opl]);
				for(int i=opl;i&lt;=gtrg(belong[opl]);++i)	fa[i]=max(fa[i]-opx,1),updtop(i);
				for(int i=gtlf(belong[opl]);i&lt;opl;++i)	updtop(i);
				turndown(belong[opr]);
				for(int i=gtlf(belong[opr]);i&lt;=opr;++i)	fa[i]=max(fa[i]-opx,1),updtop(i);
				for(int i=opr+1;i&lt;=gtrg(belong[opr]);++i)	updtop(i);
				for(int i=belong[opl]+1;i&lt;belong[opr];++i)
				{
					if(deln[i]&gt;=bs)	tag[i]+=opx;
					else
					{
						++deln[i];
						for(int j=gtlf(i);j&lt;=gtrg(i);++j)	fa[j]=max(fa[j]-opx,1),updtop(j);
					}
				}
			}
		}
		else
		{
			int opx,opy; scanf(&quot;%d %d&quot;,&amp;opx,&amp;opy);
			while(opx^opy)
			{
				int fopx,fopy;
				if(deln[belong[opx]]&gt;=bs)	turndown(belong[opx]),fopx=fa[opx];
				else	fopx=top[opx];
				if(deln[belong[opy]]&gt;=bs)	turndown(belong[opy]),fopy=fa[opy];
				else	fopy=top[opy];
				if(belong[opx]^belong[opy])
				{
					if(belong[opx]&gt;belong[opy])	opx=fopx;
					else	opy=fopy;
				}
				else if(fopx^fopy)	opx=fopx,opy=fopy;
				else
				{
					if(opx&gt;opy)	turndown(belong[opx]),opx=fa[opx];
					else	turndown(belong[opy]),opy=fa[opy];
				}
			}
			printf(&quot;%d\n&quot;,opx);
		}
	}
	return 0;
}
</code></pre>

    <script src="../components/layout.js"></script>
  </body>
</html>
