<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solution Set -「CF 1525」 | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Solution Set -「CF 1525」</h1><h1>「CF 1525A」Potion-making</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/A">Link</a>.</p>
<p>显然。</p>
<details>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
typedef long long ll;
template&lt;typename T&gt;void sf(T &amp;x){x=0;T f=0;char c=getchar();for(;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;;c=getchar())if(c==&#39;-&#39;)f=1;for(;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^&#39;0&#39;);if(f)x=-x;}
template&lt;typename T&gt;void pf(T x,char l=&#39;\n&#39;){static T s[100],t;if(x&lt;0)putchar(&#39;-&#39;),x=-x;do s[++t]=x%10,x/=10;while(x);while(t)putchar(s[t--]^&#39;0&#39;);putchar(l);}
int gcd(int x,int y){return !y?x:gcd(y,x%y);}
int main()
{
	int T,k;
	sf(T);
	while(T--&gt;0)
	{
		sf(k);
		int p1=k,p2=100-k,x=gcd(p1,p2);
		p1/=x;
		p2/=x;
		pf(p1+p2);
	}
	return 0;
}
</code></pre>
</details>

<h1>「CF 1525B」Permutation Sort</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/B">Link</a>.</p>
<p>注意到答案只有 $0/1/2/3$，分类讨论即可。</p>
<p><del>吃了三发罚时</del></p>
<details>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
typedef long long ll;
template&lt;typename T&gt;void sf(T &amp;x){x=0;T f=0;char c=getchar();for(;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;;c=getchar())if(c==&#39;-&#39;)f=1;for(;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^&#39;0&#39;);if(f)x=-x;}
template&lt;typename T&gt;void pf(T x,char l=&#39;\n&#39;){static T s[100],t;if(x&lt;0)putchar(&#39;-&#39;),x=-x;do s[++t]=x%10,x/=10;while(x);while(t)putchar(s[t--]^&#39;0&#39;);putchar(l);}
int T,n,a[60];
int main()
{
	for(sf(T);T;--T)
	{
		sf(n);
		for(int i=1;i&lt;=n;++i)	sf(a[i]);
		int flag=1;
		for(int i=2;i&lt;=n;++i)
		{
			if(a[i]!=a[i-1]+1)
			{
				flag=0;
				break;
			}
		}
		if(!flag)
		{
			if(a[1]==n &amp;&amp; a[n]==1)	puts(&quot;3&quot;);
			else if(a[n]==n || a[1]==1)	puts(&quot;1&quot;);
			else	puts(&quot;2&quot;);
		}
		else	puts(&quot;0&quot;);
	}
	return 0;
}
</code></pre>
</details>

<h1>「CF 1525C」Robot Collisions</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/C">Link</a>.</p>
<p>显然我不会。</p>
<details>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define mp make_pair
template&lt;typename T&gt;void sf(T &amp;x) {
    x = 0;
    T f = 0;
    char c = getchar();

    for (; c &lt; &#39;0&#39; || c &gt; &#39;9&#39;; c = getchar())
        if (c == &#39;-&#39;)
            f = 1;

    for (; c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = getchar())
        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c^&#39;0&#39;);

    if (f)
        x = -x;
}
template&lt;typename T&gt;void pf(T x, char l = &#39;\n&#39;) {
    static T s[100], t;

    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;

    do
        s[++t] = x % 10, x /= 10;

    while (x)
        ;

    while (t)
        putchar(s[t--]^&#39;0&#39;);

    putchar(l);
}
struct st {
    int a, b, id;
} Sts[300005], Uji[300005], Qql[300005];
bool cmp(st A, st B) {
    return A.a &lt; B.a;
}
int reait[300005];
int n, m;
int U(int x, int y) {
    int res = 0;

    if (Sts[x].a &lt; Sts[y].a) {
        if (Sts[x].b == 0)
            res += Sts[x].a, Sts[x].a = 0;

        if (Sts[y].b == 1)
            res += (m - Sts[y].a), Sts[y].a = m;

        return (res + abs(Sts[x].a - Sts[y].a)) / 2;
    } else {
        if (Sts[x].b == 1)
            res += (m - Sts[x].a), Sts[x].a = m;

        if (Sts[y].b == 0)
            res += Sts[y].a, Sts[y].a = 0;

        return (res + abs(Sts[x].a - Sts[y].a)) / 2;
    }
}
signed main() {
    int T;
    sf(T);

    while (T--) {
        sf(n), sf(m);

        for (int i = 1; i &lt;= n; i++)
            reait[i] = -1;

        int rks = 0, tss = 0;

        for (int i = 1; i &lt;= n; i++) {
            sf(Sts[i].a);
            Sts[i].id = i;
        }

        for (int i = 1; i &lt;= n; i++) {
            char res = getchar();

            while (res != &#39;L&#39; &amp;&amp; res != &#39;R&#39;)
                res = getchar();

            Sts[i].b = res == &#39;R&#39;;
        }

        for (int i = 1; i &lt;= n; i++) {
            if (Sts[i].a &amp; 1)
                Qql[++tss] = Sts[i];
            else
                Uji[++rks] = Sts[i];
        }

        sort(Uji + 1, Uji + rks + 1, cmp);
        sort(Qql + 1, Qql + tss + 1, cmp);
        stack &lt;int&gt; Q;
        Q.push(1);

        for (int i = 2; i &lt;= rks; i++) {
            if (Uji[i].b == 0 &amp;&amp; !Q.empty()) {
                int u = Q.top();
                Q.pop();
                reait[Uji[i].id] = reait[Uji[u].id] = U(Uji[i].id, Uji[u].id);
            } else
                Q.push(i);
        }

        while (!Q.empty()) {
            int u = Q.top();
            Q.pop();

            if (!Q.empty()) {
                int v = Q.top();
                Q.pop();
                reait[Uji[u].id] = reait[Uji[v].id] = U(Uji[u].id, Uji[v].id);
            }
        }

        Q.push(1);

        for (int i = 2; i &lt;= tss; i++) {
            if (Qql[i].b == 0 &amp;&amp; !Q.empty()) {
                int u = Q.top();
                Q.pop();
                reait[Qql[i].id] = reait[Qql[u].id] = U(Qql[i].id, Qql[u].id);
            } else
                Q.push(i);
        }

        while (!Q.empty()) {
            int u = Q.top();
            Q.pop();

            if (!Q.empty()) {
                int v = Q.top();
                Q.pop();
                reait[Qql[u].id] = reait[Qql[v].id] = U(Qql[u].id, Qql[v].id);
            }
        }

        for (int i = 1; i &lt;= n; i++)
            printf(&quot;%lld &quot;, reait[i]);

        printf(&quot;\n&quot;);
    }

    return 0;
}
</code></pre>
</details>

<h1>「CF 1525D」Armchairs</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/D">Link</a>.</p>
<p>设 $f(i,j)$ 表示考虑把第 $j$ 个人放进前 $i$ 个座位里的方案，转移。</p>
<p>多久没写 DP 了啊，这种水平的 DP 都写漏一堆东西。</p>
<details>

<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
typedef long long ll;
template&lt;typename T&gt;void sf(T &amp;x){x=0;T f=0;char c=getchar();for(;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;;c=getchar())if(c==&#39;-&#39;)f=1;for(;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^&#39;0&#39;);if(f)x=-x;}
template&lt;typename T&gt;void pf(T x,char l=&#39;\n&#39;){static T s[100],t;if(x&lt;0)putchar(&#39;-&#39;),x=-x;do s[++t]=x%10,x/=10;while(x);while(t)putchar(s[t--]^&#39;0&#39;);putchar(l);}
int n,a[5010],fr[5010],t0,oc[5010],t1,op[5010];
ll dp[5010][5010],ans=std::numeric_limits&lt;ll&gt;::max();
inline int fs(int x){return x&lt;0?-x:x;}
int main()
{
	sf(n);
	for(int i=1;i&lt;=n;++i)
	{
		sf(a[i]);
		if(a[i])	oc[++t1]=i;
		else	fr[++t0]=i;
	}
	for(int i=1;i&lt;=t1;++i)	for(int j=0;j&lt;=n;++j)	dp[i][j]=1e18;
	for(int i=1;i&lt;=t1;++i)	for(int j=1;j&lt;=n;++j) {
		dp[i][j]=dp[i][j-1];
		if(!a[j])	dp[i][j]=std::min(dp[i][j],dp[i-1][j-1]+fs(oc[i]-j));
	}
	pf(dp[t1][n]);
	return 0;
}
</code></pre>
</details>

<h1>「CF 1525E」Assimilation IV</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/E">Link</a>.</p>
<details>

<pre><code class="language-cpp">// Oops, something went wrong.
</code></pre>
</details>

<h1>「CF 1525F」Goblins And Gnomes</h1>
<p><a href="https://codeforces.com/problemset/problem/1525/F">Link</a>.</p>
<details>

<pre><code class="language-cpp">// Oops, something went wrong.
</code></pre>
</details>
    <script src="../components/layout.js"></script>
  </body>
</html>
