<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solution -「JRKSJ R1」吊打 | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Solution -「JRKSJ R1」吊打</h1><p>考虑线段树。</p>
<p>当然不能直接维护序列，我们来维护序列元素的指数。</p>
<p>具体来说，若 $a_i=(c^{2})^{b_i}$，我们维护的就是 $b_i$，当然 $c^2$ 也要维护。</p>
<p>这里不能取一次方，否则 $b_i$ 为奇数时就不能开方了。</p>
<p>开方就是花神的做法，能开就直接开，否则就对指数打减标记。</p>
<p>平方简单，直接对指数打加标记。</p>
<p>最后统计答案就遍历线段树，然后快速幂计算即可。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
#define ls (x&lt;&lt;1)
#define rs (x&lt;&lt;1|1)
const int mod=998244353;
int pwr[8000010],val[800010],tag[800010],n,m,a[200010];//,b[200010];
int qkpow(int bas,int fur,int mod){
	int res=1;
	while(fur){
		if(fur&amp;1)res=res*bas%mod;
		bas=bas*bas%mod,fur&gt;&gt;=1;
	}
	return res%mod;
}
void psup(int x){pwr[x]=min(pwr[ls],pwr[rs]),val[x]=max(val[ls],val[rs]);}
void psdn(int x){
	if(tag[x]){
//		int m=(l+r)/2;
		pwr[ls]+=tag[x],pwr[rs]+=tag[x];
		tag[ls]+=tag[x],tag[rs]+=tag[x];
		tag[x]=0;
	}
}
void build(int l,int r,int x){
	if(l==r)return(void)((pwr[x]=0,val[x]=a[l]));
	int m=(l+r)/2;
	build(l,m,ls),build(m+1,r,rs);
	psup(x);
}
void open(int l,int r,int x,int ql,int qr){
	if(val[x]&lt;=1)return;
	if(l&gt;=ql&amp;&amp;r&lt;=qr&amp;&amp;pwr[x]&gt;=1)return void((tag[x]--,pwr[x]--));
	if(l==r) {
		if(pwr[x]) return void(pwr[x] --);
		return void(val[x]=sqrt(val[x]));
	}
	int m=(l+r)/2;psdn(x);
	if(m&gt;=ql)open(l,m,ls,ql,qr);
	if(m&lt;qr)open(m+1,r,rs,ql,qr);
	psup(x);
}
void pinf(int l,int r,int x,int ql,int qr){
	if(val[x]&lt;=1)return;
	if(l&gt;qr||r&lt;ql)return;
	if(l&gt;=ql&amp;&amp;r&lt;=qr)return(void)((tag[x]++,pwr[x]++));
	int m=(l+r)/2;psdn(x);
	if(m&gt;=ql)pinf(l,m,ls,ql,qr);
	if(m&lt;qr)pinf(m+1,r,rs,ql,qr);
	psup(x);
}
//int get(int t){
//	int res=0;
//	if(t==1)return 0;
//	while(1){
//		int tmp=pow(t,0.5);
//		if(tmp*tmp==t)t=tmp,res++;
//		else break;
//	}
//	return res;
//}
int solve(int l,int r,int x){
	if(l==r){
		if(pwr[x]&gt;0)return qkpow(val[x],qkpow(2,pwr[x],mod-1),mod);
		else return val[x];
	}
	int m=(l+r)/2;psdn(x);
	return (solve(l,m,ls)+solve(m+1,r,rs))%mod;
}
signed main(){
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
//	memset(pwr,0x7f,sizeof(pwr));
	for(int i=1;i&lt;=n;++i){
		scanf(&quot;%d&quot;,&amp;a[i]);
//		b[i]=get(a[i]);
//		if(b[i]&gt;0)a[i]=pow(a[i],1.0/(b[i]*2));
	}
	build(1,n,1);
	while(m--){
		int t,l,r;scanf(&quot;%lld%lld%lld&quot;,&amp;t,&amp;l,&amp;r);
		if(t==1)open(1,n,1,l,r);
		else pinf(1,n,1,l,r);
	}
	printf(&quot;%lld\n&quot;,solve(1,n,1));
	return 0;
}
//don&#39;t forget to mod
</code></pre>

    <script src="../components/layout.js"></script>
  </body>
</html>
