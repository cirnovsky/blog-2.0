<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Note -「Object Oriented Segment Tree」 | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Note -「Object Oriented Segment Tree」</h1><p>没想到吧。</p>
<p>其实本文旨在以 <strong>object oriented</strong> 的方式工程化地描述线段树的抽象结构，大概是在翻译 ACL 的 <code>lazysegtree</code>。</p>
<p>在线段树上的结点中，有两种信息，分别称为 <code>S</code>，<code>F</code>，一个是维护的信息，一个是懒惰标记，又对应两个「空值」<code>e()</code> 和 <code>id()</code>。</p>
<p>线段树依赖于两个儿子的值是 <code>S</code>，依赖于父亲的值是 <code>F</code>，定义一个函数 <code>op(x, y)</code>，其中 $x,y\in\mathbb{S}$ 表示 $x,y$ 合并的结果，这个规则是自定义的，且需要满足结合律和交换律；以及 <code>composition(x, y)</code>，其中 $x,y\in\mathbb{F}$，表示把懒惰标记 $x$ <strong>单向</strong>传递到懒惰标记 $y$ 上后的结果，其规则同样是自定义的。如果不理解为什么是单向请参考 <em>Range Affine, Range Sum</em> 问题。</p>
<p>类似于 <code>composition(x, y)</code> 使得可以让一个在 $\mathbb{F}$ 中的元素传递到另一个属于 $\mathbb{F}$ 的元素身上，我们有 <code>mapping(x, y)</code> 表示从 $\mathbb{F}$ 到 $\mathbb{S}$ 的映射，其中 $x\in\mathbb{F}$，$y\in\mathbb{S}$。</p>
<p>其实可以发现所谓的 <code>S</code> 就是一类<strong>幺半群</strong>（monoid），注意 <code>F</code> 显然不具有此类性质，但是 <code>F</code> 的 <code>composition(x, y)</code> 是有<strong>封闭性</strong>的。</p>
<p><a href="https://www.luogu.com.cn/problem/P3373">例题 P3373，</a><a href="https://www.cnblogs.com/orchid-any/articles/15153763.html">示例代码见此处，特征码 acl-k。</a></p>
<p>闲话，如果你的代码实现真的分这么细码量会激增哦。（</p>

    <script src="../components/layout.js"></script>
  </body>
</html>
