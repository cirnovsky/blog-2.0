<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solution -「P2656」采蘑菇 | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Solution -「P2656」采蘑菇</h1><h2>题意简述</h2>
<p>给定一张有向图，边有边权。每次经过一条边获得边权并将边权乘一个常数。求能获得的最大权值。</p>
<h2>题解</h2>
<p>其他题解都是Tarjan。这个时候怎么能不上简单好背的Kosaraju呢！</p>
<p>思路很明确，找到图中的环然后榨干这个环的边。然后缩点，加上缩点后的权值。然后跑一个dfs即可。</p>
<p>具体来说就是就是如果每条边不在同一个SCC里面，就两个SCC连边。</p>
<p>如果在一个SCC里面，就把这个SCC里面所有边榨干后的权值和表示为点权。</p>
<p>最后预处理一下每条边被榨干后的权值和即可。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

const int MAXN = 8e5 + 5;
vector &lt; int &gt; classic_graph[MAXN];
vector &lt; int &gt; inverse_graph[MAXN];
int n, m, head[MAXN], to[MAXN &lt;&lt; 1], val[MAXN &lt;&lt; 1], dis[MAXN];
int tot, nxt[MAXN &lt;&lt; 1], prepare[MAXN], rnk[MAXN], rec[MAXN];
int inv, S, sum_val[MAXN];
struct EdgeNode {
	int from;
	int to, val;
} cass[MAXN];

void make_edge(int x, int y, int z) {
	to[++tot] = y, val[tot] = z;
	nxt[tot] = head[x], head[x] = tot;
}

void to_init() {
	memset(rec, (inv = 0), sizeof rec);
}

void positive(int x) {
	rec[x] = 1;
	for (auto y : classic_graph[x]) if (!rec[y]) positive(y);
	rnk[++inv] = x;
}

void negative(int x) {
	rec[x] = inv;
	for (auto y : inverse_graph[x]) if (!rec[y]) negative(y);
}

void dfs(int x) {
	if (!dis[x]) {
		dis[x] = sum_val[x];
		int res = 0;
		for (int i = head[x]; i; i = nxt[i])
			dfs(to[i]), res = max(res, dis[to[i]] + val[i]);
		dis[x] += res;
	}
}

void kosaraju() {
	to_init();
	for (int i = 1; i &lt;= n; ++i) if (!rec[i]) positive(i);
	to_init();
	for (int i = n; i &gt;= 1; --i) if (!rec[rnk[i]]) inv++, negative(rnk[i]);
}

void preparing() {
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for (int i = 0, x, y, z; i &lt; m; ++i) {
		double delta;
		scanf(&quot;%d %d %d %lf&quot;, &amp;x, &amp;y, &amp;z, &amp;delta);
		cass[i + 1] = EdgeNode{x, y, z};
		classic_graph[x].push_back(y);
		inverse_graph[y].push_back(x);
		while (z) prepare[i + 1] += z, z = floor(z * delta);
	}
	scanf(&quot;%d&quot;, &amp;S);
}

void get_answer() {
	kosaraju();
	for (int i = 1; i &lt;= m; ++i)
		if (rec[cass[i].from] == rec[cass[i].to]) sum_val[rec[cass[i].from]] += prepare[i];
		else make_edge(rec[cass[i].from], rec[cass[i].to], cass[i].val);
	dfs(rec[S]);
	printf(&quot;%d\n&quot;, dis[rec[S]]);
}

signed main() {
	preparing();
	get_answer();
	return 0;
}
</code></pre>

    <script src="../components/layout.js"></script>
  </body>
</html>
