<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Journey / Solution Set - 「NOIP-S 2020」「Prob. A-C」 | 汪站</title>
    <link rel="stylesheet" href="../output.css" />
  </head>
  <body>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <h1>Journey / Solution Set - 「NOIP-S 2020」「Prob. A-C」</h1><p>这种东西怎么写啊。。。</p>
<h3>Day 1（好像也没有 Day 2</h3>
<p>到了 NK 后发现正好可以进门，于是就什么也没有检查的进去了。</p>
<p>进门前问了一下 LYC 之前问过的一个问题，他说没有头绪，然后就没怎么说话了。</p>
<p>在去考场的途中和大 LJS 瞎扯了一下 CF 的 bitmasks 瘤子题。</p>
<p>小 ljs 在考场外面等的时候问我 KMP 怎么打。（伏笔 x1</p>
<p>我告诉他没有关系，碰见全部哈希（伏笔 x2。</p>
<p>快要进门的时候发现 WXK、TR、高一正在互相进行仪式。</p>
<p>然后就没有什么了。</p>
<p>进了考场之后打开 Dev，把快读之类的东西打了打，果然还是不习惯辣么大个的 Enter。</p>
<p>右边的右边是 WXK，坐下时互相说了句：“好巧啊”，然后互相迷惑地做了一下 orz 动作。</p>
<p>左边的左边是 TLY，直接 yyds。</p>
<p>然后，然后就发题了嘛，打开看见文件夹里一个 <code>string</code> 我就知道事情不对。</p>
<p>此时尧姐的 flag 倒了：“今年考字符串、计数我把这个键盘夹着草稿纸吃了。”</p>
<p>打开 PDF，先用了整整半个小时通读了一下，感觉 T1、T2 简单题，T3、T4 只能骗。</p>
<p>于是乎细读了一下 T1，发现是个 DFS 模拟水题。（当时没有往拓扑想，不过反正都是对的）</p>
<p>然后花了半个小时的样子过完了所有大样例，还很 sb 地认为不会报 <code>int</code>。不过保险起见还是在代码开头和考场的草稿纸（指记事本 <code>text.txt</code>，事实上考场上的草稿纸质量太劣我没用）都写了一句 <code>Beware of your LONG LONG</code> 以提醒自己最后十五分钟再重新考虑会不会爆。</p>
<p>然后看 T2，想了大概五分钟出了一个翻过来枚举就是 $\Theta(n\ln n)$ 大众 84pts 的垃圾做法。</p>
<p>此时想起了 YHN 学长在暑假的时候讲的话：“在考场上有一个暴力就先打一个，可以在正解死亡时应急以及对拍。”</p>
<p>然后就开始打这个 伪·$\Theta(n^{2})$。然后打出了一个 180+ 行的垃圾。</p>
<p>T3 带 SPJ，此时教练的 flag 倒了：“NOIP 不会考带 SPJ 的东西，以后不要考了。”</p>
<p>T3 又是个构造，此时教练的 flag 又倒了：“NOIP 不会考构造，以后不要考了。”</p>
<p>到了后面就根本不想打正解了，只想着调自己的暴力。结果就是调到后面越调越慌，连改思路的想法都没有。</p>
<p>最后就改了个 T1 的 <code>long long</code>，什么也没有干。</p>
<p>于是，NOIP2020 成了至暗时刻。</p>
<p>出来考场后，我问 LYC T2 的复杂度，他说：“$\Theta(Tn\sqrt{n})$”。我当时就以为块 YC 打了个分块。</p>
<p>中午大家一起到某个不知名的地方吃了一个疑似火锅的东西。</p>
<p>桌子上小 ljs 跟我一样 T2 陷在 $\Theta(n^2)$ 潮流中，其他人都打了 84。</p>
<p>然后说着说着 LYC 发现自己 T1 读错了题（后来被证实是出题人语文差，自己也没考虑这些，于是读错题 没 有 关 系），蒙着发现自己也读错了。</p>
<p>然后就觉得，要完，这下没了（本来就没了好吧）。</p>
<p>本来大家都十分快乐的对着自己的答案，然后尧姐冒了一句：“大家不要对了，伤感情。”</p>
<p>于是 LYC 对着这个 T12 没对出错 T34 骗分稳健的人喊了一句：“对了半天没对出错，有优越感了是吧。”</p>
<p>十分奇妙的，本来大家都对吃没有什么兴趣，LYC 和 LJS 这两个饭量小的早就不吃了，结果 TR 点的虾滑来之后一个二个都站了起来。</p>
<p>感觉就这样了吧，NOIP2020 是灰色但打醒的。</p>
<h3>Sol.</h3>
<h4>A 排水系统</h4>
<p>找出所有的起点 DFS 即可，可以手动实现一个分数类。</p>
<details>

<pre><code class="language-cpp">/* Beware of your __INT128 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

namespace MySpace {
typedef long long LL;

const __int128 MAXN = 1e5 + 5, MAXS = 10 + 5, MAXE = 1e5 + 5;

__int128 rint () {
	__int128 x = 0, f = 1; char c = getchar ();
	for ( ; c &lt; &#39;0&#39; || c &gt; &#39;9&#39;; c = getchar () )	f = ( c == &#39;-&#39; ? -1 : f );
	for ( ; c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = getchar () )	x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( c &amp; 15 );
	return x * f;
}

template&lt;typename _T&gt;
void wint ( _T x ) {
	if ( x &lt; 0 )	putchar ( &#39;-&#39; ), x = ~ x + 1;
	if ( x &gt; 9 )	wint ( x / 10 );
	putchar ( x % 10 + &#39;0&#39; );
}

__int128 calcGCD ( const __int128 a, const __int128 b ) ;
__int128 calcLCM ( const __int128 a, const __int128 b ) ;

struct GraphSet {
	__int128 to, nx;
	GraphSet ( __int128 T = 0, __int128 N = 0 ) { to = T, nx = N; }
} as[MAXN * 5 * 4];

struct Frac {
	__int128 one, ano;
	Frac ( __int128 O = 0, __int128 A = 0 ) { one = O, ano = A; }
} nds[MAXN];

__int128 n, stn, edn, bgn[MAXN], cnte, ind[MAXN], outd[MAXN], sts[MAXN], eds[MAXN], stnd, ednd, vis[MAXN];

void makeEdge ( const __int128 u, const __int128 v ) { as[++ cnte] = GraphSet ( v, bgn[u] ), bgn[u] = cnte; }
__int128 calcGCD ( const __int128 a, const __int128 b ) { return ! b ? a : calcGCD ( b, a % b ); }
__int128 calcLCM ( const __int128 a, const __int128 b ) { return ( ! a || ! b ) ? 0 : ( __int128 )a / calcGCD ( a, b ) * b; }
void getSimp ( Frac&amp; fr ) { __int128 ret = calcGCD ( fr.one, fr.ano ); if ( ! ret )	fr = Frac (); else fr.one /= ret, fr.ano /= ret; }

void dfs ( const __int128 u ) {
	for ( __int128 i = bgn[u]; i; i = as[i].nx ) {
		__int128 v = as[i].to;
		Frac ad = Frac ( nds[u].one, nds[u].ano * outd[u] );
		getSimp ( ad );
		__int128 ret = calcLCM ( ad.ano, nds[v].ano );
		if ( ! ret )	nds[v] = ad, dfs ( v );
		else {
			__int128 ads = ret / ad.ano, us = ret / nds[v].ano;
			ad.one *= ads, ad.ano *= ads;
			nds[v].one *= us, nds[v].ano *= us;
			nds[v].one += ad.one;
			getSimp ( nds[v] );
			dfs ( v );
		}
	}
	if ( bgn[u] )	nds[u] = Frac ();
}

void Main () {
	n = rint (), stn = rint ();
	for ( __int128 i = 1; i &lt;= n; ++ i ) {
		__int128 eg = rint ();
		for ( __int128 j = 1; j &lt;= eg; ++ j ) {
			__int128 to = rint ();
			makeEdge ( i, to );
			ind[to] ++, outd[i] ++;
		}
	}
	for ( __int128 i = 1; i &lt;= n; ++ i ) {
		if ( ! ind[i] )	sts[++ stnd] = i;
		if ( ! outd[i] )	eds[++ ednd] = i;
	}
	for ( __int128 i = 1; i &lt;= stnd; ++ i )	nds[sts[i]].one = nds[sts[i]].ano = 1;
	sort ( eds + 1, eds + 1 + ednd );
	for ( __int128 i = 1; i &lt;= stnd; ++ i )	dfs ( i );
	for ( __int128 i = 1; i &lt;= ednd; ++ i )	wint ( nds[eds[i]].one ), putchar ( &#39; &#39; ), wint ( nds[eds[i]].ano ), putchar ( &#39;\n&#39; );
}
}

int main () {
//	freopen ( &quot;water.in&quot;, &quot;r&quot;, stdin );
//	freopen ( &quot;water.out&quot;, &quot;w&quot;, stdout );
	MySpace :: Main ();
	return 0;
}
</code></pre>
</details>

<h4>B 字符串匹配</h4>
<p>这里是 $\Theta(Tn\ln n+26Tn)$，我 yy 出来的一个 $\Theta(n\ln n+Tn)$ 的做法由于太过繁杂不想想了。</p>
<p>首先枚举 $AB$ 即循环节，然后挨个往后面跳记个数就好了。</p>
<details>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;

namespace mySpace {
typedef long long LL;

const int KEY = 1331;
const int MAXN = ( 1 &lt;&lt; 20 ) + 5;

int mul ( const LL a, const LL b, const int p ) { return a * b % p; }
int add ( const int a, const int b, const int p ) { return ( a + b ) &lt; p ? ( a + b ) : ( a + b - p ); }
int sub ( const int a, const int b, const int p ) { return ( a - b ) &lt; 0 ? ( a - b + p ) : ( a - b ); }
struct Value {
	static const int onemod = 19260817, anomod = 998244353;
	int p, q;
	Value () : p ( 0 ), q ( 0 ) {}
	Value ( const int x ) : p ( x ), q ( x ) {}
	Value ( const int a, const int b ) : p ( a ), q ( b ) {}
	Value operator * ( const Value &amp;other ) const { return Value ( mul ( p, other.p, onemod ), mul ( q, other.q, anomod ) ); }
	Value operator + ( const Value &amp;other ) const { return Value ( add ( p, other.p, onemod ), add ( q, other.q, anomod ) ); }
	Value operator - ( const Value &amp;other ) const { return Value ( sub ( p, other.p, onemod ), sub ( q, other.q, anomod ) ); }
	bool operator == ( const Value &amp;other ) const { return p == other.p &amp;&amp; q == other.q; }
	bool operator != ( const Value &amp;other ) const { return ! ( Value ( p, q ) == other ); }
} pwr[MAXN], has[MAXN];

int n, mps[MAXN], buc[MAXN][26], suf[MAXN];
char str[MAXN];

void initial () {
	scanf ( &quot;%s&quot;, str + 1 ), n = strlen ( str + 1 );
	for ( int i = 1; i &lt;= n; ++ i )	mps[i] = str[i] - &#39;a&#39;;
	bool tmp[26] = {}; int cur = 0;
	for ( int i = 1; i &lt;= n; ++ i ) {
		has[i] = has[i - 1] * KEY + mps[i];
		memcpy ( buc[i], buc[i - 1], sizeof ( int ) * 26 );
		tmp[mps[i]] ^= 1, cur += tmp[mps[i]] ? 1 : -1;
		for ( int j = cur; j &lt; 26; ++ j )	buc[i][j] ++;
	}
	memset ( tmp, 0, sizeof ( tmp ) ), cur = 0;
	for ( int i = n; i; -- i )	tmp[mps[i]] ^= 1, cur += tmp[mps[i]] ? 1 : -1, suf[i] = cur;
}

Value calcHS ( const int l, const int r ) { return has[r] - has[l - 1] * pwr[r - l + 1]; }
void solve () {
	initial (); LL ans = 0;
	for ( int len = 2; len &lt; n; ++ len ) {
		Value tmp = calcHS ( 1, len );
		for ( int nxt = len; nxt &lt; n; nxt += len ) {
			if ( calcHS ( nxt - len + 1, nxt ) != tmp )	break;
			ans += buc[len - 1][suf[nxt + 1]];
		}
	}
	printf ( &quot;%lld\n&quot;, ans );
}

void main () {
	pwr[0] = 1;
	for ( int i = 1; i &lt;= MAXN - 5; ++ i )	pwr[i] = pwr[i - 1] * KEY;
	int TC; scanf ( &quot;%d&quot;, &amp;TC );
	while ( TC -- &gt; 0 )	solve ();
}
}

int main () {
//	freopen ( &quot;string.in&quot;, &quot;r&quot;, stdin );
//	freopen ( &quot;string.out&quot;, &quot;w&quot;, stdout );
	mySpace :: main ();
	return 0;
}
</code></pre>
</details>

<h4>C 移球游戏</h4>
<p>首先肯定这是 $n$ 个栈。先看 $n=2$ 的部分分。</p>
<p>这种情况只有黑白两色。</p>
<p>设 $1$ 柱有 $b$ （总共）个黑棋，有 $w$ 个白棋，把 $2$ 柱上 $b$ 个棋子放到 $3$ 柱上，然后重复：</p>
<ul>
<li>把 $1$ 柱顶部所有黑棋放到 $2$ 柱上。</li>
<li>然后把 $1$ 柱上所有白棋放到 $3$ 柱。</li>
</ul>
<p>直到 $1$ 柱为空。</p>
<p>然后把 $3$ 柱上面本属于 $1$ 柱的白棋放回去，又把 $2$ 柱上面的 $b$ 个黑棋放到 $1$ 柱去。</p>
<p>于是乎现在 $1$ 柱的情况大概是这样的：</p>
<p>假设原本是这样的：
$
\begin{aligned}
&amp;\texttt{W W B W W B W W B B B} \
&amp;\texttt{W B W B B B W B W B W}
\end{aligned}
$
那么现在移完后是这样：
$
\begin{aligned}
&amp;\texttt{W W W W W W B B B B B} \
&amp;\texttt{W B W B B B} \
&amp;\texttt{W B W B W}
\end{aligned}
$
然后我们把此时 $2$ 柱上的棋子全部放到 $3$ 柱上去，然后就划分一下就完了。</p>
<p>后面的事情就简单了，当 $n&gt;2$ 的时候打个分治，一半一半划分染色，然后按着按着整理。</p>
<p>（代码和 CQ 队长 jiangly 对拍过，不过莫名奇妙就变成了基因比照，于是代码就基本变成了 jiangly 的）</p>
<details>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;

using namespace std;

namespace mySpace {
const int MAXN = 50 + 5, MAXM = 400 + 5, MAXK = 820000 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c &lt; &#39;0&#39; || c &gt; &#39;9&#39;; c = getchar () )	f = c == &#39;-&#39; ? -1 : f;
	for ( ; c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = getchar () )	x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( c &amp; 15 );
	return x * f;
}

template&lt;typename _T&gt;
void wint ( _T x ) {
	if ( x &lt; 0 )	putchar ( &#39;-&#39; ), x = ~ x + 1;
	if ( x &gt; 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ &#39;0&#39; );
}

struct Stack {
private:
	int stk[MAXM], _top;
public:
	Stack () { memset ( stk, 0, sizeof ( stk ) ), _top = 0; }
	void push ( const int val ) { stk[_top ++] = val; }
	void pop () { if ( _top )	_top --; }
	int at ( const int pos ) { return stk[pos]; }
	int top () { return stk[_top - 1]; }
	int size () { return _top; }
	bool empty () { return _top &lt; 0; }
	void debug ( char c = &#39; &#39; ) {
		putchar ( &#39;[&#39; );
		for ( int i = 0; i &lt; _top; ++ i )	printf ( &quot;%d &quot;, stk[i] );
		printf ( &quot;]%c&quot;, c ) ;
	}
} clr[MAXN];

struct Answer {
	int one, ano;
	Answer ( int O = 0, int A = 0 ) { one = O, ano = A; }
} ans[MAXK];

int n, m, cnt;

void trans ( const int one, const int ano ) {
	clr[ano].push ( clr[one].top () );
	clr[one].pop ();
	ans[cnt ++] = Answer ( one, ano );
}

void solve ( const int l, const int r, const vector&lt;int&gt;&amp; col ) {
	if ( r - l == 1 )	return;
	int mid = ( l + r ) &gt;&gt; 1;
	int lst = col[0];
	vector&lt;int&gt; onevec, anovec;
	for ( int i = 1; i &lt; r - l; ++ i ) {
		int one = lst, ano = col[i], cnt = 0;
		for ( int j = 0; j &lt; m; ++ j ) {
			if ( clr[one].at ( j ) &lt; mid )	++ cnt;
		}
		for ( int j = 0; j &lt; cnt; ++ j )	trans ( ano, n );
		for ( int j = m - 1; ~ j; -- j ) {
			if ( clr[one].at ( j ) &lt; mid )	trans ( one, ano );
			else	trans ( one, n );
		}
		for ( int j = 0; j &lt; m - cnt; ++ j )	trans ( n, one );
		for ( int j = 0; j &lt; cnt; ++ j )	trans ( ano, one );
		for ( int j = 0; j &lt; m - cnt; ++ j )	trans ( ano, n );
		for ( int j = 0; j &lt; cnt; ++ j )	trans ( one, ano );
		for ( int j = m - 1; ~ j; -- j ) {
			if ( clr[ano].size () &lt; m &amp;&amp; ( clr[n].at ( j ) &lt; mid || clr[one].size () == m ) )	trans ( n, ano );
			else	trans ( n, one );
		}
		bool was = 0;
		for ( int j = 0; j &lt; m; ++ j ) {
			if ( clr[ano].at ( j ) &gt;= mid )	was = 1;
		}
		if ( was )	anovec.push_back ( one ), lst = ano;
		else	onevec.push_back ( ano ), lst = one;
	}
	if ( clr[lst].at ( 0 ) &lt; mid )	onevec.push_back ( lst );
	else	anovec.push_back ( lst );
	solve ( l, mid, onevec ), solve ( mid, r, anovec );
}

void main () {
	n = rint (), m = rint ();
	for ( int i = 0; i &lt; n; ++ i ) {
		for ( int j = 0; j &lt; m; ++ j )	clr[i].push ( rint () - 1 );
	}
	vector&lt;int&gt; col;
	for ( int i = 0; i &lt; n; ++ i )	col.push_back ( i );
	solve ( 0, n, col );
	wint ( cnt ), putchar ( &#39;\n&#39; );
	for ( int i = 0; i &lt; cnt; ++ i ) {
		wint ( ans[i].one + 1 ), putchar ( &#39; &#39; );
		wint ( ans[i].ano + 1 ), putchar ( &#39;\n&#39; );
	}
}
}

int main () {
//	freopen ( &quot;ball.in&quot;, &quot;r&quot;, stdin );
//	freopen ( &quot;ball.out&quot;, &quot;w&quot;, stdout );
	mySpace :: main ();
	return 0;
}
</code></pre>
</details>
    <script src="../components/layout.js"></script>
  </body>
</html>
