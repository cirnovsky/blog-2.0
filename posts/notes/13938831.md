---
date: '2020-11-06'
title: 'Record -ã€ŒNOIP-S 2020ã€èµ›å‰å¼ºåŸº'

---

æ²‰å¿ƒé™æ°”ï¼Œå°‘é€¼ä¸¤å¥ã€‚

### HDU6832 Very Easy Graph Problem - AC

å»ºå‡ºä¸€æ£µ $\texttt{MST}$ï¼Œç„¶åä¹±ç®—ä¸€ä¸‹å³å¯ã€‚

<details>

```cpp
#include <cstdio>
#include <algorithm>
#define mod ( 1000000007 )

using namespace std;
typedef long long LL;

const int MAXN = 1e5 + 5, MAXM = 2e5 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

struct starS{
	int to, nx, wt;
	starS( int T = 0, int N = 0, int W = 0 ){ to = T; nx = N; wt = W; }
} as[MAXM * 2];

struct edgeS{
	int u, v, w;
	edgeS( int U = 0, int V = 0, int W = 0 ){ u = U; v = V; w = W; }
	bool operator < ( const edgeS &another ){ return w < another.w; }
} tur[MAXM];

int N, M;
int totE, Ans;
int col[MAXN], firS[MAXN], ufs[MAXN], fur[MAXN][2];

void clearIt( ){ for( int i = 0; i <= N; ++ i )	fur[i][0] = fur[i][1] = firS[i] = totE = Ans = 0; }
void pushEdge( int u, int v, int w ){ as[++ totE] = starS( v, firS[u], w ); firS[u] = totE; }
void makeSet( int lim ){ for( int i = 1; i <= lim; ++ i )	ufs[i] = i; }
int findSet( int u ){ return u != ufs[u] ? ufs[u] = findSet( ufs[u] ) : ufs[u]; }
bool unionSet( int u, int v ){
	u = findSet( u ); v = findSet( v );
	if( u != v ){ ufs[u] = v; return 1; }
	else	return 0;
}

int Qkpow( int base, int indx ){
	int res = 1;
	while( indx ){
		if( indx & 1 )	res = ( LL )res * base % mod;
		base = ( LL )base * base % mod;
		indx >>= 1;
	}
	return res;
}

void Spannin( ){
	makeSet( N ); sort( tur + 1, tur + 1 + M );
	for( int i = 1; i <= M; ++ i ){
		int u = tur[i].u, v = tur[i].v, w = Qkpow( 2, tur[i].w );
		if( unionSet( u, v ) ){ pushEdge( u, v, w ); pushEdge( v, u, w ); }
	}
}

void DFS( int u, int lst ){
	fur[u][col[u]] = 1;
	for( int i = firS[u]; i; i = as[i].nx ){
		int v = as[i].to;
		if( v == lst )	continue;
		DFS( v, u );
		fur[u][0] += fur[v][0]; fur[u][1] += fur[v][1];
	}
	for( int i = firS[u]; i; i = as[i].nx ){
		int v = as[i].to, w = as[i].wt;
		if( v == lst )	continue;
		for( int k = 0; k < 2; ++ k )	Ans = ( Ans + ( ( LL )( fur[0][k] - fur[v][k] ) * fur[v][k ^ 1] % mod * w % mod ) ) % mod;
	}
}

int main( ){
	int T; read( T ); while( T -- > 0 ){
		read( N ); read( M ); clearIt( );
		for( int i = 1; i <= N; ++ i ){ read( col[i] ); fur[0][col[i]] ++; }
		for( int i = 1, u, v; i <= M; ++ i ){
			read( u ); read( v );
			tur[i] = edgeS( u, v, i );
		}
		Spannin( ); DFS( 1, 0 );
		write( Ans ), putchar( '\n' );
	}
	return 0;
}
```

</details>

### Gym - 102331G Grammarly - AC

æˆ‘ä»¬ç”¨ $(S)$ è¡¨ç¤ºå­—ç¬¦ä¸² $S$ åœ¨è‡ªåŠ¨æœºä¸Šçš„èŠ‚ç‚¹ã€‚

å…ˆè€ƒè™‘æ²¡æœ‰ç›¸é‚»å­—ç¬¦ç›¸åŒçš„æƒ…å†µï¼Œè¿™æ ·å»ºå‡ºæ¥çš„è‡ªåŠ¨æœºå°±æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼Œç­”æ¡ˆä¸º $2^{n}-1$ã€‚

è€ƒè™‘ç›¸é‚»å­—ç¬¦æœ‰ç›¸åŒçš„æƒ…å†µã€‚æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªæé•¿çš„å­ä¸²ï¼Œè®¾ä¸º $S'\in S$ï¼Œæ»¡è¶³å¯¹ $\forall i,j$ï¼Œæœ‰  $s_{i}=s_{j}$ã€‚

è®¾ $S'$ åœ¨ $S$ ä¸­çš„åŒºé—´ä¸º $[l,r]$ï¼Œåˆ™æˆ‘ä»¬æœ‰ ${l-1+|S|-r\choose l-1}$ã€‚ç„¶åå› ä¸º $S'$ çš„å®šä¹‰ï¼Œæ‰€ä»¥ $(S')$ ä¸‹é¢æ˜¯ä¸€æ¡é•¿åº¦ä¸º $r-l+1$ çš„é“¾ã€‚

å› æ­¤ $S'$ çš„è´¡çŒ®ä¸º ${l-1+|S|-r\choose l-1}\times(r-l+1)$ã€‚

ç„¶åæˆ‘ä»¬æšä¸¾å‰/åç¼€ç®—å­ä¸²è´¡çŒ®ï¼š
$$
\texttt{prefix:}\sum_{i=l}^{r-1}{l-2+|S|-i\choose l-2}\times(i-l+1)
$$
$$
\texttt{suffix:}\sum_{i=l+1}^{r}{i-2+|S|-r\choose i-1}\times(r-i+1)
$$
æœ€ååŠ ä¸ªï¼š
$$
\sum_{l=1}^{|S|}{l+n-r\choose l}
$$

<details>

```cpp
#include <cstdio>
#define mod ( 998244353 )

typedef long long LL;

const int MAXN = 5e5 + 5;

int N;
int fac[MAXN], inv[MAXN];
char str[MAXN];

int strlen( const char * str ){
	int res = 0;
	for( ; * ( str ++ ) != '\0'; ++ res ) ;
	return res;
}

void Exgcd( int A, int B, int &x, int &y ){
	if( ! B ){ x = 1; y = 0; }
	else{ Exgcd( B, A % B, y, x ); y -= ( A / B ) * x; }
}

int Inv( int val ){
	int res, was;
	Exgcd( val, mod, res, was );
	return ( res % mod + mod ) % mod;
}

void ProgressFacts( ){
	fac[0] = 1;
	for( int i = 1; i <= N; ++ i )	fac[i] = ( LL )fac[i - 1] * i % mod;
	for( int i = 0; i <= N; ++ i )	inv[i] = Inv( fac[i] );
}

int C( int n, int k ){ return ( LL )fac[n] * inv[k] % mod * inv[n - k] % mod; }
int main( ){
	scanf( "%s", str + 1 );
	N = strlen( str + 1 );
	ProgressFacts( );
	int Ans = 0;
	for( int l = 1, r; l <= N; l = r + 1 ){
		r = l;
		while( str[r] == str[r + 1] )	r ++;
		Ans = ( Ans + ( LL )C( l - 1 + N - r, l - 1 ) * ( r - l + 1 ) % mod ) % mod;
		for( int i = l; i < r; ++ i )	Ans = ( Ans + ( LL )C( l - 2 + N - i, l - 2 ) * ( i - l + 1 ) % mod ) % mod;
		for( int i = l + 1; i <= r; ++ i )	Ans = ( Ans + ( LL )C( i - 2 + N - r, i - 1 ) * ( r - i + 1 ) % mod ) % mod;
		for( int i = l; i <= r; ++ i )	Ans = ( Ans + C( i - 1 + N - r, i ) ) % mod;
	}
	printf( "%d\n", Ans );
	return 0;
}
```

</details>

### HDU6805 Deliver the Cake - AC

å‚»é€¼ç»†èŠ‚ã€‚

æ‹†ç‚¹è·‘æœ€çŸ­è·¯å³å¯ã€‚

<details>

```cpp
#include <cstdio>
#include <queue>

using namespace std;
typedef long long LL;

const int MAXN = 1e6 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

struct heapS{
	int pnt;
	LL val;
	heapS( int P = 0, LL V = 0 ){ pnt = P; val = V; }
	bool operator < ( const heapS &another ) const { return val < another.val; }
};

struct starS{
	int to, nx;
	LL wt;
	starS( int T = 0, int N = 0, LL W = 0 ){ to = T; nx = N; wt = W; }
} as[MAXN * 2];

int N, M, S, T, X;
int totE;
int firS[MAXN], col[MAXN], vis[MAXN];
LL dis[MAXN];
char str[MAXN];

void clearIt( ){ for( int i = 0; i <= N * 2 + 5; ++ i ){ vis[i] = 0; dis[i] = 1e18; firS[i] = 0; } totE = 0; }
void pushingEdge( int u, int v, LL w ){ as[++ totE] = starS( v, firS[u], w ); firS[u] = totE; }
void pushEdge( int u, int v, LL w ){ pushingEdge( u, v, w ); pushingEdge( v, u, w ); }

LL GetPath( int S, int T ){
	priority_queue<heapS> align;
	align.push( heapS( S, 0 ) );
	dis[S] = 0;
	while( ! align.empty( ) ){
		int u = align.top( ).pnt;
		align.pop( );
		if( vis[u] )	continue;
		vis[u] = 1;
		for( int i = firS[u]; i; i = as[i].nx ){
			int v = as[i].to;
			LL w = as[i].wt;
			if( dis[v] > dis[u] + w ){
				dis[v] = dis[u] + w;
				align.push( heapS( v, -dis[v] ) );
			}
		}
	}
	return dis[T];
}

int main( ){
	int TC; read( TC ); while( TC -- > 0 ){
		read( N ); read( M ); read( S ); read( T ); read( X );
		scanf( "%s", str + 1 ); clearIt( );
		for( int i = 1; i <= N; ++ i ){
			char c = str[i];
			if( c == 'L' )	col[i] = 0;
			else if( c == 'R' )	col[i] = 1;
			else	col[i] = 2;
		}
		for( int i = 1, u, v; i <= M; ++ i ){
			LL w;
			read( u ); read( v ); read( w );
			if( col[u] == 0 ){
				if( col[v] == 0 )	pushEdge( u, v, w );
				else if( col[v] == 1 )	pushEdge( u, v, w + X );
				else{ pushEdge( u, v, w ); pushEdge( u, v + N, w + X ); }
			}
			else if( col[u] == 1 ){
				if( col[v] == 1 )	pushEdge( u, v, w );
				else if( col[v] == 0 )	pushEdge( v, u, w + X );
				else{ pushEdge( u, v, w + X ); pushEdge( u, v + N, w ); }
			}
			else{
				if( col[v] == 0 ){ pushEdge( u, v, w ); pushEdge( u + N, v, w + X ); }
				else if( col[v] == 1 ){ pushEdge( u, v, w + X ); pushEdge( u + N, v, w ); }
				else{ pushEdge( u, v, w ); pushEdge( u + N, v + N, w ); pushEdge( u + N, v, w + X ); pushEdge( u, v + N, w + X ); }
			}
		}
		if( str[S] == 'M' ){ pushEdge( 0, S, 0 ); pushEdge( 0, S + N, 0 ); S = 0; }
		if( str[T] == 'M' ){ pushEdge( T, 2 * N + 1, 0 ); pushEdge( T + N, 2 * N + 1, 0 ); T = 2 * N + 1; }
		write( GetPath( S, T ) ), putchar( '\n' );
	}
	return 0;
}
```

</details>

### CF107B Basketball Team

ä»¤

$$
S=\sum_{i=1}^{m}s_{i}
$$
æ‰€æœ‰æƒ…å†µæ•°ï¼š
$$
{S-1\choose n-1}
$$
ä¸å¯èƒ½çš„æƒ…å†µæ•°ï¼š
$$
{S-m_{h}\choose n-1}
$$
ç­”æ¡ˆï¼š
$$
1-\frac{{S-m_{h}\choose n-1}}{{S-1\choose n-1}}
$$
ä½†æ˜¯è¿™é¢˜æ²¡æ¨¡æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½ç»§ç»­åŒ–ç®€ï¼ˆæ‘Šæ‰‹ï¼‰ã€‚
$$
\begin{aligned}
\mathrm{ANS}
&=1-\frac{{S-m_{h}\choose n-1}}{{S-1\choose n-1}} \\
&=1-\frac{\frac{(S-m_{h})!}{(n-1)!(S-m_{h}-n+1)!}}{\frac{(S-1)!}{(n-1)!(S-n)!}} \\
&=1-\frac{\frac{(S-m_{h})!}{(n-1)!(S-m_{h}-n+1)!}\times(n-1)!(S-n)!}{(S-1)!} \\
&=1-\frac{\frac{(S-m_{h})!}{(S-m_{h}-n+1)!}\times(S-n)!}{(S-1)!} \\
&=1-\frac{\frac{(S-m_{h})!}{(S-n+2-m_{h}-1)!}\times(S-n)!}{(S-1)!} \\
&=1-\frac{\frac{(S-n)!}{(S-n-(m_{h}-1))!}\times(S-m_{h})!}{(S-1)!} \\
&=1-\frac{(\prod_{i=S-n-m_{h}+2}^{S-n}i)\times(S-1-(m_{h}-1))!}{(S-1)!} \\
&=1-\frac{(\prod_{i=S-n-m_{h}+2}^{S-n}i)}{\prod_{i=S-m_{h}+1}^{S-1}i} \\
\end{aligned}
$$

<details>

```cpp
#include <cstdio>

const int MAXN = 1e3 + 5;

int N, M, H, S;
int nums[MAXN];

int main( ){
	scanf( "%d%d%d", &N, &M, &H );
	for( int i = 1; i <= M; ++ i ){ scanf( "%d", &nums[i] ); S += nums[i]; }
	if( S < N ){ puts( "-1" ); return 0; }
	double Ans = 1;
	for( int i = S - N - nums[H] + 2; i <= S - N; ++ i )	Ans *= i;
	for( int i = S - nums[H] + 1; i <= S - 1; ++ i )	Ans /= i;
	printf( "%.10lf\n", 1 - Ans );
	return 0;
}
```

</details>

### P4345 SHOI2015 è¶…èƒ½ç²’å­ç‚®Â·æ”¹ - AC

$$
p=2333 \\
\begin{aligned}f(n,k)&\equiv\sum_{i=0}^{k}{n\choose i} \\
&\equiv\sum_{i=0}^{k}{\lfloor\frac{n}{p}\rfloor\choose\lfloor\frac{i}{p}\rfloor}\times{n\bmod p\choose i\bmod p} \\
&\equiv\sum_{i=1}^{p-1}\left({n\bmod p\choose i}\times\sum_{j=0}^{k}{\lfloor\frac{n}{p}\rfloor\choose\lfloor\frac{i}{p}\rfloor}[j\bmod p=i]\right) \\
&\equiv\sum_{i=1}^{p-1}\left({n\bmod p\choose i}\times\sum_{j=0}^{\lfloor\frac{k-i}{p}\rfloor}{\lfloor\frac{n}{p}\rfloor\choose i}\right) \\
&\equiv\sum_{i=1}^{p-1}\left({n\bmod p\choose i}\times f(\lfloor\frac{n}{p}\rfloor,\lfloor\frac{k-i}{p}\rfloor)\right) \\
\end{aligned}
\space(\operatorname{mod}p)
$$

<details>

```cpp
#include <cstdio>
#define mod ( 2333 )

typedef long long LL;

const int MAXN = mod + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T> _T MIN( const _T x, const _T y ){ return x > y ? y : x; }

int N, K;
int cB[MAXN][MAXN];

void progressCbN( ){
	for( int i = 0; i < MAXN; ++ i )	cB[i][0] = 1;
	for( int i = 1; i < MAXN; ++ i ){
		for( int j = 1; j <= i; ++ j )	cB[i][j] = ( cB[i - 1][j] + cB[i - 1][j - 1] ) % mod;
	}
	for( int i = 1; i < MAXN; ++ i ){
		for( int j = 1; j <= i; ++ j )	cB[i][j] = ( cB[i][j] + cB[i][j - 1] ) % mod;
	}
}

int calc( int n, int k ){
	if( n < mod )	return cB[n][MIN( n, k )];
	if( ! k )	return 1;
	int emp = cB[n % mod][MIN( n % mod, k % mod )];
	if( k - ( k % mod ) )	emp = ( emp + ( LL )( cB[n % mod][n % mod] - cB[n % mod][MIN( n % mod, k % mod )] + mod ) % mod * calc( n / mod, ( k - ( k % mod ) - 1 ) / mod ) % mod ) % mod;
	return emp;
}

int main( ){
	progressCbN( );
	int TC; read( TC ); while( TC -- > 0 ){ read( N ); read( K ); write( calc( N, K ) ); putchar( '\n' ); }
	return 0;
}
```

</details>

### BZOJ4403 åºåˆ—ç»Ÿè®¡ - AC

$$
\begin{aligned}
\mathrm{ANS}
&\equiv\sum_{i=1}^{n}{i+r-l\choose r-l} \\
&\equiv{n+r-l+1\choose r-l+1}-1
\end{aligned}
\space(\operatorname{mod} p)
$$

<details>

```cpp
#include <cstdio>
#define mod ( 1000003 )

typedef long long LL;

const int MAXN = mod + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

int N, L, R;
int fac[MAXN], ifac[MAXN];

void Exgcd( int a, int b, int &x, int &y ){ if( ! b ){ x = 1; y = 0; } else{ Exgcd( b, a % b, y, x ); y -= ( a / b ) * x; } }
int Inv( int val ){ int res, was; Exgcd( val, mod, res, was ); return ( res + mod ) % mod; }
int C( int n, int k ){ return n < k ? 0 : ( LL )fac[n] * ifac[k] % mod * ifac[n - k] % mod; }
int Lucas( int n, int k ){ return ! k ? 1 : ( LL )Lucas( n / mod, k / mod ) * C( n % mod, k % mod ) % mod; }
void prepareNumber( int lim ){ fac[0] = ifac[0] = 1; for( int i = 1; i <= lim; ++ i ){ fac[i] = ( LL )fac[i - 1] * i % mod; ifac[i] = Inv( fac[i] ); } }

int main( ){
	prepareNumber( MAXN - 5 );
	int TC; read( TC ); while( TC -- > 0 ){ read( N ); read( L ); read( R ); write( ( Lucas( N + R - L + 1, R - L + 1 ) - 1 + mod ) % mod ); putchar( '\n' ); }
	return 0;
}
```

</details>

### P2606 ZJOI2010 æ’åˆ—è®¡æ•° - AC

æ˜¯ä¸ªå †ï¼Œäºæ˜¯ $f_{i}=f_{2i}\times f_{2i+1}\times{S_{i}-1\choose S_{2i}}$ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 2e6 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

int N, P;
int fur[MAXN], fac[MAXN], ifac[MAXN];

void Exgcd( int a, int b, int &x, int &y ){ if( ! b ){ x = 1; y = 0; } else{ Exgcd( b, a % b, y, x ); y -= ( a / b ) * x; } }
int Inv( int val, int mod ){ int res, was; Exgcd( val, mod, res, was ); return ( res + mod ) % mod; }
int C( int n, int k, int p ){ return n < k ? 0 : ( LL )fac[n] * ifac[k] % p * ifac[n - k] % p; }
int Lucas( int n, int k, int p ){ return ! k ? 1 : ( LL )Lucas( n / p, k / p, p ) * C( n % p, k % p, p ) % p; }
void GetSize( int u ){ if( u > N )	return; fur[u] = 1; GetSize( u << 1 ); GetSize( u << 1 | 1 ); fur[u] += fur[u << 1] + fur[u << 1 | 1]; }
int GetAnsw( int u, int p ){ if( u > N )	return 1; return ( LL )Lucas( fur[u] - 1, fur[u << 1], p ) * GetAnsw( u << 1, p ) % p * GetAnsw( u << 1 | 1, p ) % p; }
void PapNum( int n, int p ){ fac[0] = ifac[0] = 1; for( int i = 1; i <= n; ++ i ){ fac[i] = ( LL )fac[i - 1] * i % p; ifac[i] = Inv( fac[i], p ); } }

int main( ){
	read( N ); read( P ); PapNum( MAXN - 5, P );
	GetSize( 1 ); write( GetAnsw( 1, P ) );
	return 0;
}
```

</details>

### P3773 CTSC2017 å‰å¤«ç‰¹ - AC

$$
\begin{aligned}
&\ \ \ \ \prod_{i=2}^{k}{a_{b_{i}-1}\choose a_{b_{i}}} \\
&\equiv\prod_{i=2}^{k}{\lfloor\frac{a_{b_{i}-1}}{2}\rfloor\choose\lfloor\frac{a_{b_{i}}}{2}\rfloor}\times{a_{b_{i}-1}\bmod2\choose a_{b_{i}}\bmod2}
\end{aligned}
(\operatorname{mod} 2)
$$

å¼å­åé¢çš„ $\dbinom{a_{b_{i}-1}\bmod2}{a_{b_{i}\bmod2}}$ ä¸€å…±æœ‰å››ç§æƒ…å†µï¼Œå…¶ä¸­åªæœ‰ $\dbinom{0}{1}=0$ã€‚å…¶ä»–éƒ½ä¸º $1$ã€‚

æ„å‘³ç€åªè¦å‡ºç° $a_{b_{i}-1}\equiv0\bmod2$ ä¸” $a_{b_{i}}\equiv1\bmod1$ çš„æƒ…å†µï¼Œæ•´ä¸ªå¼å­å°±ä¸ºé›¶äº†ã€‚

ç»“è®ºï¼š$\dbinom{n}{m}\equiv0\space(\operatorname{mod}2)$ å½“ä¸”ä»…å½“ $n\operatorname{bitand} =m$ã€‚

è¯æ˜ï¼ˆä¹Ÿè®¸ä¸æ˜¯ç‰¹åˆ«ä¸¥è°¨ï¼‰ï¼šæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š
$$
{n\choose m}={\lfloor\frac{n}{2}\rfloor\choose\lfloor\frac{m}{2}\rfloor}\times{n\bmod 2\choose m\bmod2}={\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor\choose\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}\times {\lfloor\frac{n}{2}\rfloor\bmod2\choose\lfloor\frac{m}{2}\rfloor\bmod2}\times{n\bmod 2\choose m\bmod2}=\cdots
$$
æˆ‘ä»¬å‘ç°ï¼š
$$
{\lfloor\frac{\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor\choose\lfloor\frac{\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor}
$$
è¿™ä¸€å¨ï¼Œå°±æ˜¯åœ¨ä¸€ç›´è¿›è¡ŒäºŒè¿›åˆ¶ç§»ä½ï¼Œ$\operatorname{shr}1$ã€‚

é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸€ä¸ªç»“è®ºï¼šå¦‚æœå¯¹äºæˆ‘ä»¬è®° $(n)_{k}$ è¡¨ç¤º $n$ åœ¨äºŒè¿›åˆ¶æ„ä¹‰ä¸‹çš„ç¬¬ $k$ ä½ã€‚$(n)_{k}\in[0,1]$

é‚£ä¹ˆå¯¹äº $\forall i$ï¼Œæœ‰ $(n)_{i}=0$ ä¸” $(m)_{i}=1$ï¼Œé‚£ä¹ˆ $\dbinom{n}{m}\equiv0\space(\operatorname{mod} 2)$ã€‚

æ‰€ä»¥ $n\operatorname{bitand}m=m$ï¼Œè¯æ¯•ã€‚

æˆ‘ä»¬é¢˜ç›®è¦æ±‚çš„æ˜¯æœ€åç®—å‡ºæ¥æ˜¯ä¸ªå¥‡æ•°ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å­˜åœ¨ $a_{b_{i}-1}\operatorname{bitand}a_{b_{i}}=a_{b_{i}}$ã€‚

ä¹Ÿå°±æ˜¯ $a_{b_{i}}$ ä¸º $a_{b_{i}-1}$ çš„å­é›†ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸€ä¸ª DPï¼Œæˆ‘ä»¬è®¾ $f_{i}$ ä¸ºä»¥ $a_{i}$ ä¸ºå¼€å¤´çš„ç­”æ¡ˆã€‚

é‚£ä¹ˆè½¬ç§»å°±æ˜¯åŠ æ³•åŸç†ï¼š
$$
f_{i}=f_{i}+f_{j},j\in a_{i}\wedge t_{j}>i
$$
å…¶ä¸­ $t_{i}$ è¡¨ç¤º $i$ åœ¨åºåˆ—ä¸­çš„ä½ç½®ã€‚

æ—¶é—´å¤æ‚åº¦ç”±äºŒé¡¹å¼å®šç†å¯çŸ¥æ˜¯ $\Theta(3^{\log_{2}\max\{a_{i}\}})$ã€‚

<details>

```cpp
#include <cstdio>
#define mod ( 1000000007 )

const int MAXN = 250000 + 5;

int N;
int val[MAXN], dp[MAXN];
int buc[MAXN];

int main( ){
	scanf( "%d", &N ); for( int i = 1; i <= N; ++ i ){ scanf( "%d", &val[i] ); buc[val[i]] = i; }
	int Ans = 0;
	for( int i = N; i; -- i ){
		dp[i] = 1;
		for( int j = val[i] & ( val[i] - 1 ); j; j = ( j - 1 ) & val[i] ){
			if( buc[j] > i )	dp[i] = ( dp[i] + dp[buc[j]] ) % mod;
		}
		Ans = ( Ans + dp[i] ) % mod;
	}
	printf( "%d\n", ( Ans - N + mod ) % mod );
	return 0;
}
```

</details>

### CF1151E Number of Components - IP

è€ƒè™‘è½¬åŒ–å¯¹è¿é€šå—çš„è®¡æ•°ã€‚è¿é€šå—æ•°é‡ç­‰äºå›¾ä¸­çš„æ‰€æœ‰ç‚¹æ•°å‡å»ç‚¹ä¹‹é—´çš„è¾¹çš„æ•°é‡ã€‚

é‚£ä¹ˆæˆ‘ä»¬çš„åŸºæœ¬æ€è·¯å°±æ˜¯åˆ†å¼€ç»Ÿè®¡ç‚¹æ•°å’Œè¾¹æ•°ã€‚

å…ˆè€ƒè™‘ç‚¹ $u$ï¼Œå®ƒä¼šäº§ç”Ÿè´¡çŒ®å½“ä¸”ä»…å½“ $a_{u}\in[l,r]$ï¼Œè€Œ $l\in[1,n],r\in[l,n]$ï¼Œæ‰€ä»¥ $u$ çš„è´¡çŒ®æ¬¡æ•°ä¸º $a_{u}\times(n-a_{u}+1)$ï¼Œç”»ä¸ªæ•°è½´å°±è¡Œäº†ã€‚

åœ¨è€ƒè™‘ä¸€æ¡è¾¹ $(u,v)$ï¼Œå®ƒä¼šäº§ç”Ÿè´¡çŒ®å½“ä¸”ä»…å½“ $a_{u}\in[l,r]\wedge a_[v]\in[l,r]$ï¼Œæ‰€ä»¥ $(u,v)$ çš„è´¡çŒ®æ¬¡æ•°ä¸º $\min\{a_{u},a_{v}\}\times(n-\max\{a_{u},a_{v}\}+1)$ï¼Œæ³¨æ„è¿™é‡Œçš„è´¡çŒ®æ˜¯è´Ÿçš„ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5;

template<typename _T> _T MIN( const _T x, const _T y ){ return x > y ? y : x; }
template<typename _T> _T MAX( const _T x, const _T y ){ return x > y ? x : y; }

int N;
int a[MAXN];

int main( ){
	scanf( "%d", &N );
	for( int i = 1; i <= N; ++ i )	scanf( "%d", &a[i] );
	LL Ans = 0;
	for( int i = 1; i <= N; ++ i )	Ans += ( LL )a[i] * ( N - a[i] + 1 );
	for( int i = 1; i < N; ++ i )	Ans -= ( LL )MIN( a[i], a[i + 1] ) * ( N - MAX( a[i], a[i + 1] ) + 1 );
	printf( "%lld\n", Ans );
	return 0;
}
```

</details>

### ACW214 Devu å’Œé²œèŠ± - AC

å…ˆå‡è®¾æ¯ä¸ªç›’å­å¯ä»¥æ— é™å–ï¼Œæ¯ä¸ªç›’å­å– $x_{i}$ ä¸ªã€‚

åˆ™ $\sum_{i=1}^{N}x_{i}=M$ã€‚æ­¤æ—¶ $x_{i}\ge0$ï¼Œä¸æ˜¯ç‰¹åˆ«å¥½æã€‚

é‚£å°± $\sum_{i=1}^{N}x_{i}+1=M+N$ï¼Œç„¶åéš”ä¸ªæ¿ï¼Œç­”æ¡ˆä¸º ${N+M-1\choose N-1}$ã€‚

ä¸åˆæ³•çš„æ–¹æ¡ˆå³ä¸èƒ½å­˜åœ¨ $x_{i}>a_{i}$ï¼Œç„¶åå®¹æ–¥ä¸€ä¸‹ã€‚

è¿™ä¹ˆç…ç¬”å¼±æ™ºçš„ä»£ç è°ƒäº†ä¸€ä¸­åˆç®€ç›´ CNMã€‚ä¸¤å¤©ä¸ç¢°é”®ç›˜å°±è¿™æ ·å•Šï¼Ÿ

<details>

```cpp
#include <cstdio>
#define mod ( 1000000007 )

typedef long long LL;

const LL MAXN = 20 + 5;

LL N;
LL M;
LL a[MAXN];

void Exgcd( LL a, LL b, LL &x, LL &y ){ if( ! b ){ x = 1; y = 0; } else{ Exgcd( b, a % b, y, x ); y -= ( a / b ) * x; } }
LL Inv( LL val ){ LL res, was; Exgcd( val, mod, res, was ); return ( res + mod ) % mod; }

LL C( LL n, LL k ){
	if( n < k )	return 0;
	else if( n == k )	return 1;
	n %= mod;
	if( k > n - k )	k = n - k;
	LL one = 1, another = 1;
	for( LL i = 0; i < k; ++ i ){ one = one * ( n - i ) % mod; another = another * ( k - i ) % mod; }
	return one * Inv( another ) % mod;
}

int main( ){
	scanf( "%lld%lld", &N, &M );
	for( LL i = 1; i <= N; ++ i )	scanf( "%lld", &a[i] );
	LL Ans = C( N + M - 1, N - 1 ), Up = ( 1 << N );
	for( LL S = 1; S ^ Up; ++ S ){
		LL pS = 1, tS = 0;
		for( LL i = 1; i <= N; ++ i ){
			if( ( S >> ( i - 1 ) ) & 1 ){ pS += a[i] + 1; tS ++; }
		}
		if( tS & 1 )	Ans = ( Ans - C( N + M - pS, N - 1 ) + mod ) % mod;
		else	Ans = ( Ans + C( N + M - pS, N - 1 ) ) % mod;
	}
	printf( "%lld\n", Ans );
	return 0;
}
```

</details>

### P2757 å›½å®¶é›†è®­é˜Ÿ ç­‰å·®å­åºåˆ— / P5679 GZOI2017 ç­‰å·®å­åºåˆ— - AC

é¢˜é¢è¿·æƒ‘è‡ªå·±ã€‚

é¦–å…ˆ $Len=3$ å³å¯ï¼Œåé¢å°±æ²¡æ„ä¹‰äº†ã€‚

æ„Ÿè§‰è¿™ç§é¢˜å’Œæœ‰è¾ƒå¤§å¯èƒ½ä¸ $\texttt{bitset}$ å’Œ $\texttt{map}$ æœ‰å…³ç³»ã€‚

ç­”æ¡ˆå³å¦‚æœå­˜åœ¨ä¸€ä¸ª $a_{i}$ï¼Œéœ€è¦æ»¡è¶³ $a_{i}+k\in\{A_{1},\cdots,A_{n}\},a_{i}-k\in\{A_{1},\cdots,A_{n}\}$ï¼Œé‚£ä¹ˆè¾“å‡º $\texttt{Y}$ï¼Œå¦åˆ™è¾“å‡º $\texttt{N}$ã€‚

ç„¶åæŠŠæ‰€æœ‰ $A_{i}$ æ˜ å°„åœ¨ä¸€ä¸ªæ¡¶é‡Œï¼Œå°±å˜æˆäº†ä¸€ä¸ªåˆ¤æ–­åŒºé—´å›æ–‡çš„é—®é¢˜äº†å“¦ã€‚

ç„¶åä½ è¦ $\texttt{bitset}$ ä¹Ÿè¡Œï¼Œä¸è¿‡æ•°æ®èŒƒå›´å¤§ç‚¹å°±è¿‡ä¸å»äº†ï¼Œåæ­£æˆ‘æ‰“çº¿æ®µæ ‘ã€‚

<details>

```cpp
#include <cstdio>
#define LL long long

const unsigned LL KEY = 131;
const int MAXN = 1e4 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T> _T MIN( const _T x, const _T y ){ return x > y ? y : x; }

struct nodeS{
	unsigned LL has;
	int fur;
	nodeS( unsigned LL H = 0, int F = 0 ){ has = H; fur = F; }
	bool operator != ( const nodeS another ){ return has != another.has; }
} nodeL[MAXN * 4], nodeR[MAXN * 4];

int N;
int a[MAXN];
unsigned LL bas[MAXN];

nodeS Merge( const nodeS lch, const nodeS rch ){ return nodeS( lch.has * bas[rch.fur] + rch.has, lch.fur + rch.fur ); }
void Upt( const int x ){ nodeL[x] = Merge( nodeL[x << 1], nodeL[x << 1 | 1] ); nodeR[x] = Merge( nodeR[x << 1 | 1], nodeR[x << 1] ); }

void Build( const int x, const int l, const int r ){
	if( l == r ){ nodeL[x] = nodeR[x] = nodeS( 0, 1 ); return; }
	int mid = ( l + r ) >> 1;
	Build( x << 1, l, mid );
	Build( x << 1 | 1, mid + 1, r );
	Upt( x );
}

void Modify( const int x, const int l, const int r, const int segP, const int segW ){
	if( l == r ){ nodeL[x] = nodeR[x] = nodeS( segW, segW ); return; }
	int mid = ( l + r ) >> 1;
	if( mid >= segP )	Modify( x << 1, l, mid, segP, segW );
	else	Modify( x << 1 | 1, mid + 1, r, segP, segW );
	Upt( x );
}

nodeS QueryL( const int x, const int l, const int r, const int segL, const int segR ){
	if( l > segR || r < segL )	return nodeS( 0, 0 );
	if( l >= segL && r <= segR )	return nodeL[x];
	int mid = ( l + r ) >> 1;
	return Merge( QueryL( x << 1, l, mid, segL, segR ), QueryL( x << 1 | 1, mid + 1, r, segL, segR ) );
}

nodeS QueryR( const int x, const int l, const int r, const int segL, const int segR ){
	if( l > segR || r < segL )	return nodeS( 0, 0 );
	if( l >= segL && r <= segR )	return nodeR[x];
	int mid = ( l + r ) >> 1;
	return Merge( QueryR( x << 1 | 1, mid + 1, r, segL, segR ), QueryR( x << 1, l, mid, segL, segR ) );
}

int main( ){
	bas[0] = 1; for( int i = 1; i < MAXN; ++ i )	bas[i] = bas[i - 1] * KEY;
	int TC; read( TC ); while( TC -- > 0 ){
		read( N ); for( int i = 1; i <= N; ++ i )	read( a[i] );
		bool Ans = 0; Build( 1, 1, N );
		for( int i = 1; i <= N; ++ i ){
			Modify( 1, 1, N, a[i], 1 );
			int aimS = MIN( a[i] - 1, N - a[i] );
			if( aimS <= 0 )	continue;
			if( QueryL( 1, 1, N, a[i] - aimS, a[i] - 1 ) != QueryR( 1, 1, N, a[i] + 1, a[i] + aimS ) ){ Ans = 1; puts( "Y" ); break; }
		}
		if( ! Ans )	puts( "N" );
	}
	return 0;
}
```

</details>

### P4870 BalticOI 2009 Day1 ç”²è™« - AC

å®šä¹‰ $f_{i,j,0/1}$ è¡¨ç¤ºä¸ªå¯‚å¯ã€‚
$$
f_{i,i,0/1}=|a_{i}|\times I
$$

$$
f_{i,j,0}=\min\{f_{i+1,j,0}+(a_{i+1}-a_{i})\times(I-j+i),f_{i+1,j,1}+(a_{j}-a_{i})\times(I-j+i)\} \\f_{i,j,1}=\min\{f_{i,j-1,1}+(a_{j}-a_{j-1})\times(I-j+i),f_{i,j-1,0}+(a_{j}-a_{i})\times(I-j+i)\}
$$

$$
\mathrm{ANS}=\max\{i\times m-\min\{f_{l,r,0/1}\}\}
$$

<details>

```cpp
/* Splovex-MD */

#include <cstdio>
#include <algorithm>

using namespace std;
typedef long long LL;

const int MAXN = 300 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T> _T MIN( const _T x, const _T y ){ return x > y ? y : x; }
template<typename _T> _T MAX( const _T x, const _T y ){ return x > y ? x : y; }
template<typename _T> _T ABS( const _T x ){ return x > 0 ? x : -x; }

int N, M;
int wtS[MAXN];
LL f[MAXN][MAXN][2];

int main( ){
	// freopen( "beetle.in", "r", stdin );
	// freopen( "beetle.out", "w", stdout );
	read( N ); read( M );
	for( int i = 1; i <= N; ++ i )	read( wtS[i] );
	sort( wtS + 1, wtS + 1 + N );
	LL Ans = 0;
	for( int i = 1; i <= N; ++ i ){
		for( int j = 1; j <= N; ++ j )	f[j][j][0] = f[j][j][1] = ABS( wtS[j] ) * i;
		for( int dis = 2; dis <= N; ++ dis ){
			for( int l = 1, r = dis; r <= N; ++ l, ++ r ){
				f[l][r][0] = MIN( f[l + 1][r][0] + ( wtS[l + 1] - wtS[l] ) * ( i - r + l ), f[l + 1][r][1] + ( wtS[r] - wtS[l] ) * ( i - r + l ) );
				f[l][r][1] = MIN( f[l][r - 1][1] + ( wtS[r] - wtS[r - 1] ) * ( i - r + l ), f[l][r - 1][0] + ( wtS[r] - wtS[l] ) * ( i - r + l ) );
			}
		}
		for( int l = 1; l <= N - i + 1; ++ l ){
			int r = l + i - 1;
			Ans = MAX( Ans, i * M - MIN( f[l][r][0], f[l][r][1] ) );
		}
	}
	write( Ans );
	return 0;
}
```

</details>


### P4786 BalkanOI 2018 Election - AC

è½¬åŒ–ä¸€ä¸‹æˆæœ€å¤§å­æ®µå’Œï¼ŒåŒ–å¼å­è¿‡ç¨‹æ‡’å¾—å†™äº†ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const LL INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T> _T MIN( const _T x, const _T y ){ return x > y ? y : x; }

struct nodeS{
	LL val, pre, suf;
	nodeS( LL V = 0, LL P = 0, LL S = 0 ){ val = V; pre = P; suf = S; }
} nodes[MAXN * 4];

int N, M;
int a[MAXN], pre[MAXN], suf[MAXN];
char str[MAXN];

nodeS Merge( const nodeS lch, const nodeS rch ){ return nodeS( MIN( lch.pre + rch.suf, MIN( lch.val, rch.val ) ),
		MIN( lch.pre, rch.pre ), MIN( lch.suf, rch.suf ) ); }
void Upt( const int x ){ nodes[x] = Merge( nodes[x << 1], nodes[x << 1 | 1] ); }

void Build( const int x, const int l, const int r ){
	if( l == r ){ nodes[x] = nodeS( INF, pre[l], suf[l] ); return; }
	int mid = ( l + r ) >> 1;
	Build( x << 1, l, mid );
	Build( x << 1 | 1, mid + 1, r );
	Upt( x );
}

nodeS Query( const int x, const int l, const int r, const int segL, const int segR ){
	if( l > segR || r < segL )	return nodeS( INF, INF, INF );
	if( l >= segL && r <= segR )	return nodes[x];
	int mid = ( l + r ) >> 1;
	return Merge( Query( x << 1, l, mid, segL, segR ), Query( x << 1 | 1, mid + 1, r, segL, segR ) );
}

int main( ){
	read( N ); scanf( "%s", str + 1 );
	for( int i = 1; i <= N; ++ i ){
		if( str[i] == 'C' )	a[i] = 1;
		else	a[i] = -1;
	}
	for( int i = 1; i <= N; ++ i )	pre[i] = pre[i - 1] + a[i];
	for( int i = N; i; -- i )	suf[i] = suf[i + 1] + a[i];
	Build( 1, 0, N + 1 );
	read( M ); while( M -- > 0 ){
		int opl, opr;
		read( opl ); read( opr );
		LL ret = Query( 1, 0, N + 1, opl - 1, opr + 1 ).val;
		write( pre[opl - 1] + suf[opr + 1] - ret ), putchar( '\n' );
	}
	return 0;
}
```

</details>

### CF1451E1 Bitwise Queries (Easy Version) - AC

ç»“è®ºï¼š
$$
a+b=(a\operatorname{bitxor}b)+((a\operatorname{bitand}b)\operatorname{shl}1)
$$
è¯æ˜æ¯”è¾ƒæ˜¾ç„¶ã€‚

ç„¶åå°± $5$ æ¬¡è¯¢é—®å‡ºå‰é¢ä¸‰ä¸ªæ•°ï¼Œåˆè¯¢é—® $n-3$ æ¬¡å‡ºåé¢çš„æ•°ã€‚

<details>

```cpp
/*
theorem: a+b=(a^b)+((a&b)<<1)
ask:
a1 xor a2
a1 and a2
a1 xor a3
a1 and a3
a2 and a3
=>
a1+a2
a1+a3
(a1 xor a2) xor (a1 xor a3)=a2 xor a3
=>
a1+a2=A [1]
a1+a3=B [2]
a2+a3=C [3]
=>
a1=(A+B-C)/2
a2=(A-B+C)/2
a3=(B+C-A)/2
*/

#include <cstdio>

const int MAXN = ( 1 << 16 ) + 5;

int N;
int Ans[MAXN];

int main () {
	scanf ( "%d", &N );
	int a1xora2, a1anda2, a1xora3, a1anda3, a2xora3, a2anda3;
	printf ( "XOR 1 2\n" ), fflush ( stdout ), scanf ( "%d", &a1xora2 );
	printf ( "AND 1 2\n" ), fflush ( stdout ), scanf ( "%d", &a1anda2 );
	printf ( "XOR 1 3\n" ), fflush ( stdout ), scanf ( "%d", &a1xora3 );
	printf ( "AND 1 3\n" ), fflush ( stdout ), scanf ( "%d", &a1anda3 );
	printf ( "AND 2 3\n" ), fflush ( stdout ), scanf ( "%d", &a2anda3 );
	a2xora3 = a1xora2 ^ a1xora3;
	int A = a1xora2 + ( a1anda2 << 1 );
	int B = a1xora3 + ( a1anda3 << 1 );
	int C = a2xora3 + ( a2anda3 << 1 );
	Ans[1] = ( A + B - C ) / 2;
	Ans[2] = ( A - B + C ) / 2;
	Ans[3] = ( B + C - A ) / 2;
	for ( int i = 4; i <= N; ++ i ) {
		printf ( "XOR 1 %d\n", i );
		fflush ( stdout );
		int xorval;
		scanf ( "%d", &xorval );
		Ans[i] = xorval ^ Ans[1];
	}
	putchar ( '!' );
	for ( int i = 1; i <= N; ++ i )	printf ( " %d", Ans[i] );
	putchar ( '\n' );
	fflush ( stdout );
	return 0;
}
```

</details>

### CF1451E2 Bitwise Queries (Hard Version) - IP

Keyï¼šå€¼åŸŸ $[0,n-1]$ã€‚

é’¦å®šä¸€ä¸ªæ•° $K\in\{a_{1},\cdots,a_{n}\}$ï¼Œè¿™é‡Œä¸ºäº†æ–¹ä¾¿å– $K=a_{1}$ã€‚

ç„¶åè®¡ç®—å‡º $a'_{i}=K\operatorname{bitxor}a_{i},i\in[2,n]$ã€‚

### SP106 BINSTIRL - Binary Stirling Numbers - AC

æ±‚
$$
\begin{aligned}
\begin{Bmatrix}n \\ m\end{Bmatrix}\bmod2
&=\left(\begin{Bmatrix}n-1 \\ m-1\end{Bmatrix}+m\begin{Bmatrix}n-1 \\ m\end{Bmatrix}\right)\bmod2 \\
&=\begin{cases}
\begin{Bmatrix}n-1 \\ m-1\end{Bmatrix}\bmod2,m\equiv0\space(\operatorname{mod}2) \\
\left(\begin{Bmatrix}n-1 \\ m-1\end{Bmatrix}+\begin{Bmatrix}n-1 \\ m\end{Bmatrix}\right)\bmod2,m\equiv1\space(\operatorname{mod}2)
\end{cases}
\end{aligned}
$$
$m\equiv1\space(\operatorname{mod}2)$ çš„æƒ…å†µä¸ºç»„åˆæ•°çš„é€’æ¨ã€‚

è½¬åŒ–ä¸€ä¸‹ï¼ŒæŠŠå¡«è¡¨è½¬ç§»æ¢æˆåˆ·è¡¨ï¼Œå³

- å½“ $m\equiv0\space(\operatorname{mod}2)$ æ—¶ï¼Œ$\begin{Bmatrix}n \\ m\end{Bmatrix}$ è½¬ç§»åˆ° $\begin{Bmatrix}n+1 \\ m+1\end{Bmatrix}$ã€‚

- å½“ $m\equiv1\space(\operatorname{mod}2)$ æ—¶ï¼Œ$\begin{Bmatrix}n \\ m\end{Bmatrix}$ è½¬ç§»åˆ° $\begin{Bmatrix}n+1 \\ m+1\end{Bmatrix}$ å’Œ $\begin{Bmatrix}n+1 \\ m\end{Bmatrix}$ã€‚

é‚£ä¹ˆè¿™ä¸ªé¢˜ç›®å°±è½¬åŒ–æˆäº†åœ¨è¡¨æ ¼ä¸Š $(0,0)$ èµ°åˆ° $(n,m)$ çš„è·¯å¾„æ¡æ•° $\operatorname{mod}2$ é—®é¢˜ã€‚

ä¸¤ç§æƒ…å†µéƒ½å¯ä»¥è½¬ç§»åˆ° $\begin{Bmatrix}n+1 \\ m+1\end{Bmatrix}$ï¼Œä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬å®šä¹‰è¿™ç§æƒ…å†µä¸ºå‘å³ä¸Šè½¬ç§»ï¼ŒæŠŠ $\begin{Bmatrix}n+1 \\ m\end{Bmatrix}$ å®šä¹‰ä¸ºå‘ä¸Šè½¬ç§»ã€‚

å› ä¸ºæˆ‘ä»¬è½¬ç§»åªèƒ½å‘ä¸Šæˆ–å³ä¸Šèµ°ï¼Œæ‰€ä»¥åªä¼šèµ° $n$ æ­¥ï¼Œå…¶ä¸­ $m$ æ¬¡å‘å³ä¸Šè½¬ç§»ï¼Œ$n-m$ æ¬¡å‘å³è½¬ç§»ã€‚

æˆ‘ä»¬ä¸€å…±æœ‰ $\lfloor\frac{m+1}{2}\rfloor$ æ¬¡æœºä¼šå‘å³è½¬ç§»ï¼ˆåªèƒ½ä»å¥‡æ•°èµ°ï¼‰ã€‚

ç›¸å½“äºæˆ‘ä»¬ç°åœ¨éœ€è¦æŠŠè½¬ç§»çš„è¿‡ç¨‹åˆ†æˆ $n-m$ æ®µï¼Œæ¯ä¸€æ®µçš„å†…éƒ¨å…¨éƒ¨éƒ½æ˜¯å‘å³ä¸Šè½¬ç§»ï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½åˆ°è¾¾ $(n,m)$ã€‚

ç”¨ç›’å­ä¸çƒçš„è¯­è¨€æ¥æè¿°ï¼Œå°±æ˜¯ä¸€å…±å°±æœ‰ $n-m+\lfloor\frac{m+1}{2}\rfloor$ ä¸ªçƒï¼ˆè¿™é‡Œç†è§£èµ·æ¥å…¶å®ç‰¹åˆ«éº»çƒ¦ï¼‰ï¼ˆä¸è¿‡åªæ˜¯å¯¹äºæˆ‘è¿™ç§ç»„åˆå·®çš„äººï¼‰ï¼Œåˆ†æˆ $\lfloor\frac{m+1}{2}\rfloor$ æ®µï¼Œéš”æ¿å³å¯ã€‚

äºæ˜¯ $\begin{Bmatrix}n \\ m\end{Bmatrix}\bmod2={n-m+\lfloor\frac{m+1}{2}\rfloor-1\choose\lfloor\frac{m+1}{2}\rfloor-1}\bmod2$ã€‚

å…³äºç»„åˆæ•°å¥‡å¶æ€§ï¼Œ[æˆ‘è¿™ç¯‡åšå®¢é‡Œå†™è¿‡](https://www.luogu.com.cn/blog/161849/solution-p3773)ï¼Œå†è´´ä¸Šæ¥ï¼š

ç»“è®ºï¼š$\dbinom{n}{m}\equiv0\space(\operatorname{mod}2)$ å½“ä¸”ä»…å½“ $n\operatorname{bitand}m=m$ã€‚

è¯æ˜ï¼ˆä¹Ÿè®¸ä¸æ˜¯ç‰¹åˆ«ä¸¥è°¨ï¼‰ï¼šæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š
$$
{n\choose m}={\lfloor\frac{n}{2}\rfloor\choose\lfloor\frac{m}{2}\rfloor}\times{n\bmod 2\choose m\bmod2}={\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor\choose\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}\times {\lfloor\frac{n}{2}\rfloor\bmod2\choose\lfloor\frac{m}{2}\rfloor\bmod2}\times{n\bmod 2\choose m\bmod2}=\cdots
$$
æˆ‘ä»¬å‘ç°ï¼š
$$
{\lfloor\frac{\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor\choose\lfloor\frac{\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor}
$$
è¿™ä¸€å¨ï¼Œå°±æ˜¯åœ¨ä¸€ç›´è¿›è¡ŒäºŒè¿›åˆ¶ç§»ä½ï¼Œ$\operatorname{shr}1$ã€‚

é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸€ä¸ªç»“è®ºï¼šå¦‚æœå¯¹äºæˆ‘ä»¬è®° $(n)_{k}$ è¡¨ç¤º $n$ åœ¨äºŒè¿›åˆ¶æ„ä¹‰ä¸‹çš„ç¬¬ $k$ ä½ã€‚$(n)_{k}\in[0,1]$

é‚£ä¹ˆå¯¹äº $\forall i$ï¼Œæœ‰ $(n)_{i}=0$ ä¸” $(m)_{i}=1$ï¼Œé‚£ä¹ˆ $\dbinom{n}{m}\equiv0\space(\operatorname{mod} 2)$ã€‚

æ‰€ä»¥ $n\operatorname{bitand}m=m$ï¼Œè¯æ¯•ã€‚

ç­”æ¡ˆæ˜¾ç„¶ã€‚

<details>

```cpp
#include <cstdio>

int N, M;

int main () {
	int TC; scanf ( "%d", &TC ); while ( TC -- > 0 ) {
		scanf ( "%d%d", &N, &M );
		if ( ! N && ! M )	puts ( "1" );
		else if ( ! N || ! M || N < M )	puts ( "0" );
		else if( ( ( N - M + ( ( M + 1 ) >> 1 ) - 1 ) & ( ( ( M + 1 ) >> 1 ) - 1 ) ) == ( ( ( M + 1 ) >> 1 ) - 1 ) )	puts ( "1" );
		else	puts ( "0" );
	}
	return 0;
}
```

</details>

### CF258D Little Elephant and Broken Sorting - AC

è¦å•¥è®¾å•¥æƒ¯æ€§è®¾è®¡çŠ¶æ€ä¸å¥½ã€‚

è®¾ $f_{i,j}=P(a_{i}>a_{j}),i<j$ã€‚

æˆ‘ä»¬å‡è®¾å½“å‰æˆ‘ä»¬çš„æ“ä½œä¸ºäº¤æ¢ $a_{x},a_{y}$ã€‚

é‚£ä¹ˆ $f_{i,x}=f_{i,y}$ï¼Œä¹Ÿæœ‰ $f_{i,x}=f_{i,y}=1-f_{x,i}=1-f_{y,i}$ã€‚

è½¬ç§»æ¯”è¾ƒç¥å¥‡
$$
\begin{cases}
f_{i,x}=\frac{f_{i,x}+f_{i,y}}{2} \\
f_{i,y}=\frac{f_{i,x}+f_{i,y}}{2} \\
\end{cases}
$$
ç­”æ¡ˆå³
$$
\sum_{i=1}^{n}\sum_{j=i+1}^{n}f_{i,j}
$$
è¾¹ç•Œæ¡ä»¶
$$
f_{i,j}=[a_{i}>a_{j}],i<j
$$
è¿™é¢˜çš„çŠ¶æ€è®¾è®¡ä¹Ÿç»™æˆ‘æäº†ä¸ªé†’ï¼Œä¸è¦æƒ¯æ€§åšé¢˜ã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 1000 + 5;

int N, M;
int a[MAXN];
double f[MAXN][MAXN];

int main () {
	scanf ( "%d%d", &N, &M );
	for ( int i = 1; i <= N; ++ i )	scanf ( "%d", &a[i] );
	for ( int i = 1; i <= N; ++ i ) {
		for ( int j = 1; j <= N; ++ j ) {
			if ( a[i] > a[j] )	f[i][j] = 1;
			else	f[i][j] = 0;
		}
	}
	while ( M -- > 0 ) {
		int x, y;
		scanf ( "%d%d", &x, &y );
		for ( int i = 1; i <= N; ++ i ) {
			f[i][x] = f[i][y] = ( f[i][x] + f[i][y] ) / 2;
			f[x][i] = f[y][i] = 1 - f[i][x];
		}
		f[x][y] = f[y][x] = 0.5;
	}
	double Ans = 0;
	for ( int i = 1; i <= N; ++ i ) {
		for ( int j = i + 1; j <= N; ++ j )	Ans += f[i][j];
	}
	printf ( "%.6lf\n", Ans );
	return 0;
}
```

</details>

### AT4513 [AGC030D] Inversion Sum - AC

åŒ CF258Dï¼Œä¹˜ä¸ª $2^{q}$ å³å¯ã€‚

<details>

```cpp
#include <cstdio>
#define mod ( 1000000007 )

typedef long long LL;

const int MAXN = 3000 + 5;

int N, M;
int a[MAXN];
LL f[MAXN][MAXN];

template<typename _T> _T ADD ( const _T x, const _T y ) { return ( x + y < mod ) ? ( x + y ) : ( x + y - mod ); }
template<typename _T> _T MUL ( const _T x, const _T y ) { return ( LL )x * y % mod; }

int main () {
	scanf ( "%d%d", &N, &M );
	for ( int i = 1; i <= N; ++ i )	scanf ( "%d", &a[i] );
	for ( int i = 1; i <= N; ++ i ) {
		for ( int j = 1; j <= N; ++ j )	{
			if ( a[i] > a[j] )	f[i][j] = 1;
			else	f[i][j] = 0;
		}
	}
	LL K = ( mod + 1 ) >> 1;
	for ( int _ = 1; _ <= M; ++ _ ) {
		int x, y;
		scanf ( "%d%d", &x, &y );
		for ( int i = 1; i <= N; ++ i ) {
			if( i == x || i == y )	continue;
			f[i][x] = f[i][y] = MUL ( ADD ( f[i][x], f[i][y] ), K );
			f[x][i] = f[y][i] = MUL ( ADD ( f[x][i], f[y][i] ), K );
		}
		f[x][y] = f[y][x] = MUL ( ADD ( f[x][y], f[y][x] ), K );
	}
	LL Ans = 0;
	for ( int i = 1; i <= N; ++ i ) {
		for ( int j = i + 1; j <= N; ++ j )	Ans = ADD ( Ans, f[i][j] );
	}
	for ( int _ = 1; _ <= M; ++ _ )	Ans = ADD ( Ans, Ans );
	printf ( "%lld\n", Ans );
	return 0;
}
```

</details>

### LOC25875 å° Y çš„å›¾ - AC

[Desc. & Link.](https://www.luogu.com.cn/paste/idm2yb0i)

æ°´é¢˜

<details>

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 3e5 + 5;

template<typename _T>
void read( _T &x ){
	x = 0; char c = getchar( ); _T f = 1;
	while( c < '0' || c > '9' ){ if( c == '-' )	f = -1; c = getchar( ); }
	while( c >= '0' && c <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( c & 15 ); c = getchar( ); }
	x *= f;
}

template<typename _T>
void write( _T x ){
	if( x < 0 ){ putchar( '-' ); x = -x; }
	if( x > 9 )	write( x / 10 );
	putchar( x % 10 + '0' );
}

template<typename _T> _T MAX( const _T x, const _T y ){ return x > y ? x : y; }
template<typename _T> void swapp( _T &x, _T &y ){ _T w = x; x = y; y = w; }

struct starS{
	int to, nx, wt;
	starS( int T = 0, int N = 0, int W = 0 ){ to = T; nx = N; wt = W; }
} as[MAXN * 2];

struct edgeS{
	int u, v, w;
	edgeS( int U = 0, int V = 0, int W = 0 ){ u = U; v = V; w = W; }
	bool operator < ( const edgeS &another ){ return w < another.w; }
} tur[MAXN];

int N, M, Q;
int cnt, col;
int firS[MAXN], fa[MAXN][21], fur[MAXN][21], ufs[MAXN], vis[MAXN], dep[MAXN];

void pushEdge( const int u, const int v, const int w ){ as[++ cnt] = starS( v, firS[u], w ); firS[u] = cnt; }
void makeSet( const int w ){ for( int i = 1; i <= w; ++ i )	ufs[i] = i; }
int findSet( const int u ){ return u != ufs[u] ? ufs[u] = findSet( ufs[u] ) : ufs[u]; }
bool unionSet( int u, int v ){
	u = findSet( u ); v = findSet( v );
	if( u != v ){ ufs[u] = v; return 1; }
	else	return 0;
}

void Spannin( ){
	makeSet( N ); sort( tur + 1, tur + 1 + M );
	for( int i = 1; i <= M; ++ i ){
		int u = tur[i].u, v = tur[i].v, w = tur[i].w;
		if( ! unionSet( u, v ) )	continue;
		pushEdge( u, v, w ); pushEdge( v, u, w );
	}
}

void DFS( const int u, const int lst, const int col ){
	vis[u] = col; fa[u][0] = lst; dep[u] = dep[lst] + 1;
	for( int i = 1; i ^ 21; ++ i ){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
		fur[u][i] = MAX( fur[u][i - 1], fur[fa[u][i - 1]][i - 1] );
	}
	for( int i = firS[u]; i; i = as[i].nx ){
		int v = as[i].to, w = as[i].wt;
		if( v == lst )	continue;
		fur[v][0] = w; DFS( v, u, col );
	}
}

int Query( int u, int v ){
	if( dep[u] < dep[v] )	swapp( u, v );
	int res = 0;
	for( int i = 20; ~ i; -- i ){
		if( dep[fa[u][i]] >= dep[v] ){ res = MAX( res, fur[u][i] ); u = fa[u][i]; }
	}
	if( u == v )	return res;
	for( int i = 20; ~ i; -- i ){
		if( fa[u][i] == fa[v][i] )	continue;
		res = MAX( res, MAX( fur[u][i], fur[v][i] ) );
		u = fa[u][i]; v = fa[v][i];
	}
	res = MAX( res, MAX( fur[u][0], fur[v][0] ) );
	return res;
}

int main( ){
	read( N ); read( M ); read( Q );
	for( int i = 1, u, v, w; i <= M; ++ i ){
		read( u ); read( v ); read( w );
		tur[i] = edgeS( u, v, w );
	}
	Spannin( );
	for( int i = 1; i <= N; ++ i ){
		if( ! vis[i] )	DFS( i, 0, ++ col );
	}
	while( Q -- > 0 ){
		int u, v;
		read( u ); read( v );
		if( vis[u] != vis[v] )	write( -1 ), putchar( '\n' );
		else	write( Query( u, v ) ), putchar( '\n' );
	}
	return 0;
}
```

</details>

### LOC25874 å° W çš„é­”æœ¯ - AC

[Desc. & Link.](https://www.luogu.com.cn/paste/dwkm1jcb)

$26^{n}-26^{n-|s|}-|s|\times25\times26^{n-|s|-1}$

<details>

```cpp
#include <cstdio>
#define mod ( 998244353 )

typedef long long LL;

LL Qkpow ( LL base, LL indx ) {
	LL res = 1;
	while ( indx ) {
		if ( indx & 1 )	res = res * base % mod;
		base = base * base % mod;
		indx >>= 1;
	}
	return res;
}

LL N, S;

int main () {
	scanf ( "%lld\n", &N );
	char c = getchar ();
	for ( ; c != '\r' && c != '\n' && ~ c; c = getchar () )	S ++;
	if ( N == S )	printf ( "%lld\n", ( Qkpow ( 26, S ) - 1 + mod ) % mod );
	else if ( N < S )	printf ( "0\n" );
	else printf ( "%lld\n", ( ( Qkpow ( 26, N ) - Qkpow ( 26, N - S ) - S * 25 % mod * Qkpow ( 26, N - S - 1 ) % mod ) % mod + mod ) % mod );
	return 0;
}
```

</details>

### P6287 [COCI2016-2017#1] Mag - IP

ç»“è®ºï¼šç­”æ¡ˆé“¾ä¸Šæœ€å¤šåŒ…å«ä¸€ä¸ª $2$ï¼ˆå…¶ä½™å…¨ä¸º $1$ï¼‰ï¼Œå¹¶ä¸”ä¸åœ¨é“¾çš„ä¸¤ç«¯ç‚¹ã€‚

è¯æ˜ï¼šæˆ‘ä»¬é—®é¢˜åˆ†æˆä¸¤ä¸ª $\texttt{pass}$ã€‚

- $\texttt{pass 1}$ï¼š$\forall u,s.t.x_{u}\ge2$ã€‚

ç­”æ¡ˆæ˜¾ç„¶ä¸º $\min\{x_{u}\},u\in V$ã€‚

- $\texttt{pass 2}$ï¼š$\exists E'\subset E,s.t.x_{u}=1,u\in E'\wedge x_{v}\ge2,v\in E\setminus E'$ã€‚

- - æˆ‘ä»¬è®¾æˆ‘ä»¬é€‰å‡ºçš„é“¾ä¸ºå¤§æ¦‚è¿™æ ·çš„é€ å‹ï¼š

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow1\cdots
$$

å³ä¸€å † $1$ ä¸­å¤¹äº†ä¸€ä¸ª $X$ã€‚

æˆ‘ä»¬è®¾ $X$ å·¦è¾¹æœ‰ $l$ ä¸ªèŠ‚ç‚¹ï¼Œå³è¾¹æœ‰ $r$ ä¸ªèŠ‚ç‚¹ã€‚

åˆ™ä»·å€¼ä¸ºæ•´æ¡é“¾ $\frac{X}{l+r+1}$ï¼Œå·¦è¾¹ $\frac{1}{l}$ï¼Œå³è¾¹ $\frac{1}{r}$ã€‚

ä¸ºæ–¹ä¾¿æˆ‘ä»¬è¿™é‡Œè®¾ $l<r$ã€‚

é‚£ä¹ˆå·¦è¾¹çš„ä»·å€¼ä¸€å®šå¤§äºå³è¾¹ã€‚

è¿™é‡Œå‡è®¾ $\frac{1}{r}>\frac{X}{l+r+1}$ï¼Œåˆ™æœ‰ $X<\frac{l+1}{r}+1$ï¼Œåˆ $r\ge l+1$ï¼Œæ‰€ä»¥ $\frac{l+1}{r}\le1$ã€‚ï¼ˆåä¹‹å¯ä»¥è¯ä¼ªï¼Œæ‡’å¾—å†™äº† QwQï¼‰

æ‰€ä»¥æœ‰ $X\le2$ã€‚

åˆ $X\neq1$ï¼Œæ‰€ä»¥ $X=2$ã€‚

- - æˆ‘ä»¬è®¾æˆ‘ä»¬é€‰å‡ºçš„é“¾ä¸ºå¤§æ¦‚è¿™æ ·çš„é€ å‹ï¼š

$$
1\rightarrow1\rightarrow\cdots\rightarrow X\rightarrow1\rightarrow\cdots\rightarrow1\rightarrow Y\rightarrow1\cdots
$$

å³ä¸€å † $1$ ä¸­å¤¹äº†ä¸€ä¸ª $X$ ä¸€ä¸ª $Y$ã€‚

è¿™é‡Œæˆ‘ä»¬å¯ä»¥æŠŠ $Y$ ä»¥å‰å½“æˆ $\texttt{pass 2}$ çš„ç¬¬ä¸€ä¸ªç±»å‹ï¼Œè®¾å…¶å…±æœ‰ $N$ ä¸ªæ•°ã€‚

é‚£ä¹ˆå‡è®¾æˆ‘ä»¬åŠ å…¥ $Y$ æ›´ä¼˜ï¼Œå³æœ‰ $\frac{XY}{N+1}<\frac{X}{N}$ï¼Œåˆ™æœ‰ $NY<N+1$ï¼Œç”±äº $Y\neq1$ï¼Œæ‰€ä»¥åŠ å…¥ $Y$ æ˜¯æ›´åŠ£çš„ã€‚

åé¢çš„åŒç†å°±å¯ä»¥æ¨å¹¿äº†ã€‚

äºæ˜¯å¾—è¯ QwQã€‚

ç„¶åæˆ‘ä»¬å°±å¯ä»¥ DP äº†ã€‚

è®¾ $f_{u,0/1}$ è¡¨ç¤ºèŠ‚ç‚¹ $u$ æƒå€¼ä¸ºçš„æƒ…å†µä¸‹æœ€ä¼˜ç­”æ¡ˆã€‚

è½¬ç§»å°±åˆ†ç±»è®¨è®ºä¸€ä¸‹ï¼š

- $x_{u}=1$

$$
\begin{cases}
f_{u,0}=\max\{f_{v,0}\}+1 \\
f_{u,1}=\max\{f_{v,1}\}+1
\end{cases}
$$

- $x_{u}=2$

$$
f_{u,1}=\max\{f_{v,0}\}+1
$$

ç­”æ¡ˆä¹Ÿéœ€è¦åˆ†ç±»è®¨è®ºï¼ˆè¿™é‡Œè®¾ $x,y\in\text{son}(u)$ï¼‰ï¼š

- $x_{u}=1$

ç­”æ¡ˆä¸º $\frac{1}{\max\{f_{x,0}+f_{y,0}+1\}}$ï¼Œä»¥åŠ $\frac{2}{\max\{f_{x,0}+f_{y,1}\}+1}$ã€‚

- $x_{u}=2$

ç­”æ¡ˆä¸º $\frac{2}{\max\{f_{x,0}+f_{y,0}+1\}}$ã€‚

ç”¨å››ä¸ªå˜é‡ç»´æŠ¤æœ€å¤§ã€æ¬¡å¤§çš„ $f_{0},f_{1}$ å³å¯ã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 1e6 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -f : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MIN ( const _T x, const _T y ) { return x > y ? y : x; }

struct starS {
	int to, nx;
	starS ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, cnt, Up = 1e9, Dn = 1, mnMg = 1e9, a[MAXN], f[MAXN][2], bgin[MAXN];

void pushEdge ( const int u, const int v ) { as[++ cnt] = starS ( v, bgin[u] ); bgin[u] = cnt; }

void checkUpt ( const int x, const int y ) { if ( Up * y > Dn * x )	Up = x, Dn = y; }

void dfs ( const int u, const int lst ) {
	int mx0 = 0, se0 = 0, mx1 = 0, se1 = 0;
	for ( int i = bgin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
		if ( f[v][0] > f[mx0][0] )	se0 = mx0, mx0 = v;
		else if ( f[v][0] > f[se0][0] )	se0 = v;
		if ( f[v][1] > f[mx1][1] )	se1 = mx1, mx1 = v;
		else if ( f[v][1] > f[se1][1] )	se1 = v;
	}
	if ( a[u] == 1 ) {
		f[u][0] = f[mx0][0] + 1;
		checkUpt ( 1, f[mx0][0] + f[se0][0] + 1 );
		if ( ! mx1 )	return;
		f[u][1] = f[mx1][1] + 1;
		if ( mx0 != mx1 )	checkUpt ( 2, f[mx0][0] + f[mx1][1] + 1 );
		else {
			checkUpt ( 2, f[se0][0] + f[mx1][1] + 1 );
			if ( se1 )	checkUpt ( 2, f[mx0][0] + f[se1][1] + 1 );
		}
	}
	else if ( a[u] == 2 )	f[u][1] = f[mx0][0] + 1, checkUpt ( 2, f[mx0][0] + f[se0][0] + 1 );
}

int main () {
	n = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		pushEdge ( u, v ), pushEdge ( v, u );
	}
	for ( int i = 1; i <= n; ++ i )	a[i] = rint (), mnMg = MIN ( mnMg, a[i] );
	if ( mnMg > 1 )	wint ( mnMg ), putchar ( '/' ), wint ( 1 ), putchar ( '\n' );
	else	dfs ( 1, 0 ), wint ( Up ), putchar ( '/' ), wint ( Dn ), putchar ( '\n' );
	return 0;
}
```

</details>

### CF1009F Dominant Indices

é‡æ–°æè¿°é—®é¢˜ï¼šå¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹æ±‚å­—æ•°å†…æ¯ä¸€å±‚èŠ‚ç‚¹ä¸ªæ•°æœ€å¤šçš„ä¸€å±‚ï¼ˆè¯­æ–‡åºŸæŸ´ï¼‰ã€‚

å…ˆè€ƒè™‘æš´åŠ› DPã€‚

è®¾ $f_{u,d}$ è¡¨ç¤ºèŠ‚ç‚¹åœ¨èŠ‚ç‚¹ $u$ çš„å­æ ‘å†…æ·±åº¦ä¸º $d$ çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
$$
f_{u,d}=\sum_{v\in\text{son}(u)}f_{v,d-1}
$$
ç­”æ¡ˆæ˜¾ç„¶ã€‚

æœ¬ç€ DP é¢˜è¦æš´åŠ›æ‰“ä¸€éæ­£è§£æ‰“ä¸€éçš„åŸåˆ™æ”¾ä¸€ä¸‹æš´åŠ›ä»£ç ã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 1e3 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : 1;
	for ( ; c >= '0' && c <= '9'; c = getchar () ) x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

struct starS {
	int to, nx;
	starS ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, cnt, f[MAXN][MAXN], dep[MAXN], head[MAXN];

void pushEdge ( const int u, const int v ) { as[++ cnt] = starS ( v, head[u] ); head[u] = cnt; }

void dfs ( const int u, const int lst ) {
	dep[u] = dep[lst] + 1, f[u][0] = 1;
	for ( int i = head[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
		for ( int j = 1; j <= n; ++ j )	f[u][j] += f[v][j - 1];
	}
}

int main () {
	n = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		pushEdge ( u, v ), pushEdge ( v, u );
	}
	dfs ( 1, 0 );
	for ( int i = 1; i <= n; ++ i ) {
		int ans = 0, pos = 0;
		for ( int j = n; ~ j; -- j ) {
			if ( ans <= f[i][j] )	ans = f[i][j], pos = j;
		}
		wint ( pos ), putchar ( '\n' );
	}
	return 0;
}
```

</details>

æ¥ä¸‹æ¥æƒ³æƒ³æ­£è§£ã€‚

ç­‰ä¸‹è¿™ä¸ªä¸œè¥¿æ˜¯ä¸æ˜¯å¯ä»¥ç›´æ¥çº¿æ®µæ ‘åˆå¹¶ã€‚

å»ä½ ğŸçš„ DPã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 1e6 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -f : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x > y ? x : y; }

struct starS {
	int to, nx;
	starS ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

struct nodeS {
	int lch, rch, val, dep;
	nodeS ( int L = 0, int R = 0, int V = 0, int D = 0 ) { lch = L, rch = R, val = V, dep = D; }
} nodes[MAXN * 4];

int top, stk[MAXN * 4];
int n, cnt, tot, head[MAXN], ans[MAXN], dep[MAXN], root[MAXN];

void pushEdge ( const int u, const int v ) { as[++ cnt] = starS ( v, head[u] ), head[u] = cnt; }
int Newnode () { return top ? stk[top --] : ++ tot; }

void Upt ( const int x ) {
	nodes[x].val = MAX ( nodes[nodes[x].lch].val, nodes[nodes[x].rch].val );
	if ( nodes[x].val == nodes[nodes[x].lch].val )	nodes[x].dep = nodes[nodes[x].lch].dep;
	else	nodes[x].dep = nodes[nodes[x].rch].dep;
}

void Modify ( int& x, const int l, const int r, const int segP ) {
	if ( ! x )	x = Newnode ();
	if ( l == r )	return void ( ( nodes[x].val ++, nodes[x].dep = l ) );
	int mid = ( l + r ) >> 1;
	if ( mid >= segP )	Modify ( nodes[x].lch, l, mid, segP );
	else	Modify ( nodes[x].rch, mid + 1, r, segP );
	Upt ( x );
}

void Merge ( int& x, const int y, const int l, const int r ) {
	if ( ! x || ! y )	return void ( x += y );
	if ( l == r )	return void ( ( nodes[x].val += nodes[y].val, nodes[y] = nodeS (), stk[++ top] = y ) );
	int mid = ( l + r ) >> 1;
	Merge ( nodes[x].lch, nodes[y].lch, l, mid );	
	Merge ( nodes[x].rch, nodes[y].rch, mid + 1, r );
	Upt ( x ), nodes[y] = nodeS (), stk[++ top] = y;
}

void dfs ( const int u, const int lst ) {
	root[u] = ++ tot, dep[u] = dep[lst] + 1;
	for ( int i = head[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
		Merge ( root[u], root[v], 1, n );
	}
	Modify ( root[u], 1, n, dep[u] );
	ans[u] = nodes[root[u]].dep - dep[u];
}

int main () {
	n = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		pushEdge ( u, v ), pushEdge ( v, u );
	}
	dfs ( 1, 0 );
	for ( int i = 1; i <= n; ++ i )	wint ( ans[i] ), putchar ( '\n' );
	return 0;
}
```

</details>

### P3232 [HNOI2013]æ¸¸èµ°

<details>

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 500 + 5, MAXM = MAXN * MAXN;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }
template<typename _T> _T ABS ( const _T x ) { return x > 0 ? x : -x; }

struct starS {
	int to, nx;
	starS ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXM * 2];

struct edgeS {
	int u, v;
	double w;
	edgeS ( int U = 0, int V = 0, double W = 0 ) { u = U, v = V, w = W; }
	bool operator < ( const edgeS &another ) { return w > another.w; }
} tur[MAXM];

int n, m, cnt, head[MAXN], deg[MAXN];
double mat[MAXN][MAXN];

void pushEdge ( const int u, const int v ) { as[++ cnt] = starS ( v, head[u] ), head[u] = cnt; }

void Eradicate () {
	for ( int i = 1; i <= n; ++ i ) {
		int p = i;
		for ( int j = i + 1; j <= n; ++ j ) {
			if ( ABS ( mat[j][i] ) > ABS ( mat[p][i] ) )	p = j;
		}
		for ( int j = i; j <= n + 1; ++ j )	swapp ( mat[i][j], mat[p][j] );
		for ( int j = i + 1; j <= n; ++ j ) {
			for ( int k = i + 1; k <= n + 1; ++ k )	mat[j][k] -= mat[i][k] * mat[j][i] / mat[i][i];
		}
	}
	for ( int i = n; ~ i; -- i ) {
		for ( int j = i + 1; j <= n; ++ j )	mat[i][n + 1] -= mat[j][n + 1] * mat[i][j];
		mat[i][n + 1] /= mat[i][i];
	}
}

int main () {
	n = rint () - 1, m = rint ();
	for ( int i = 1, u, v; i <= m; ++ i ) {
		u = rint (), v = rint ();
		tur[i] = edgeS ( u, v );
		deg[u] ++, deg[v] ++;
		pushEdge ( u, v ), pushEdge ( v, u );
	}
	for ( int _ = 1; _ <= n; ++ _ ) {
		int u = _;
		for ( int i = head[u]; i; i = as[i].nx ) {
			int v = as[i].to;
			if ( v == n + 1 )	continue;
			mat[u][v] = 1.0 / deg[v];
		}
		mat[u][u] = -1;
		if ( u == 1 )	mat[u][n + 1] = -1;
	}
	Eradicate ();
	for ( int i = 1; i <= m; ++ i )	{
		int u = tur[i].u, v = tur[i].v;
		tur[i].w = mat[u][n + 1] / deg[u] + mat[v][n + 1] / deg[v];
	}
	sort ( tur + 1, tur + 1 + m );
	double ans = 0;
	for ( int i = 1; i <= m; ++ i )	ans += tur[i].w * i;
	printf ( "%.3lf\n", ans );
	return 0;
}
```

</details>

### P1600 NOIP 2016 å¤©å¤©çˆ±è·‘æ­¥ - AC

å…ˆæ‰“ä¸ªæ·±åº¦æ•°ç»„ $d$ï¼Œç„¶å $\text{dist}(u,v)=d_{u}+d_{v}-2\times d_{\text{lca}(u,v)}$ã€‚

æˆ‘ä»¬å‡è®¾ç‚¹ $u$ åœ¨å·¦è¾¹ï¼Œç‚¹ $v$ åœ¨å³è¾¹ï¼Œä»¤ $x=\text{lca}(u,v)$ï¼ˆ$u,v$ åˆ†åˆ«æ˜¯ä¸€ä½ç©å®¶çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰ã€‚

å…ˆè€ƒè™‘ $[u,x]$ è¿™æ¡è·¯å¾„ï¼Œè®¾ä¸€ä¸ªç‚¹ $k$ åœ¨è¿™æ¡é“¾ä¸Šã€‚

é‚£ä¹ˆç‚¹ $k$ çš„è§‚å¯Ÿå‘˜è§‚å¯Ÿåˆ°ç©å®¶éœ€è¦æ»¡è¶³ $w_{k}=d_{u}-d_{k}$ã€‚

å†è€ƒè™‘ $(x,v]$ è¿™æ¡è·¯å¾„ï¼Œä¹Ÿè®¾ä¸€ä¸ªç‚¹ $k$ åœ¨è¿™æ¡é“¾ä¸Šã€‚

é‚£ä¹ˆç‚¹ $k$ çš„è§‚å¯Ÿå‘˜è§‚å¯Ÿåˆ°ç©å®¶éœ€è¦æ»¡è¶³ $w_{k}=d_{u}-2\times d_{x}+d_{k}$ã€‚

é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘è½¬åŒ–ä¸€ä¸‹é—®é¢˜ï¼Œå¯¹äºæ¯ä¸€ä¸ªç‚¹çš„è§‚å¯Ÿå‘˜è€ƒè™‘æ»¡è¶³æ¡ä»¶çš„ç©å®¶æ•°é‡ç„¶åå†æŠŠç­”æ¡ˆåŠ èµ·æ¥ã€‚

æŠŠ $[u,x]$ è·¯å¾„çš„æ¡ä»¶è½¬åŒ–ä¸€ä¸‹ $w_{k}=d_{u}-d_{k}\Longrightarrow d_{u}=d_{k}+w_{k}$ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¯ä»¥æŠŠ $[u,x]$ è·¯å¾„ä¸ŠåŠ ä¸Šä¸€ä¸ªç‚¹æƒ $d_{u}$ï¼Œç„¶åè¯¢é—® $d_{k}+w_{k}$ çš„æ•°é‡ã€‚

è‡³äº $(x,v]$ çš„æƒ…å†µå’Œ $[u,x]$ å·®ä¸å¤šã€‚

æŠŠ $(x,v]$ è·¯å¾„çš„æ¡ä»¶è½¬åŒ–ä¸€ä¸‹ $w_{k}=d_{u}-2\times d_{x}+d_{k}\Longrightarrow w_{k}-d_{k}=d_{u}-2\times d_{x}$ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¯ä»¥æŠŠ $(x,v]$ è·¯å¾„ä¸ŠåŠ ä¸Šä¸€ä¸ªç‚¹æƒ $d_{u}-2\times d_{x}$ï¼Œç„¶åè¯¢é—® $w_{k}-d_{k}$ çš„æ•°é‡ã€‚

ä»¥ä¸Šä¸¤ç§æƒ…å†µéƒ½å¯ä»¥ç”¨åŠ¨æ€å¼€ç‚¹æƒå€¼ï¼ˆæ·±åº¦ï¼‰çº¿æ®µæ ‘ç„¶åçº¿æ®µæ ‘åˆå¹¶è§£å†³ï¼Œå·®åˆ†ä¸€ä¸‹å³å¯ã€‚

å“¦å¯¹äº†æƒ…å†µäºŒæœ‰å¯èƒ½æ·±åº¦å‡å‡ºè´Ÿæ•°æ‰€ä»¥éœ€è¦åŠ ä¸ª $n$ å“¦ã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 3e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 + '0' );
}

template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

struct SegmentTree {
	int lch, rch, val;
	SegmentTree ( int L = 0, int R = 0, int V = 0 ) { lch = L, rch = R, val = V; }
} nodes[MAXN * 18 * 4];

int n, m, cnt, tot, upper, begin[MAXN], depth[MAXN], kfa[MAXN][21], weight[MAXN];
int oneR[MAXN], anotherR[MAXN], ans[MAXN];

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, begin[u] ), begin[u] = cnt; }

void dfs ( const int u, const int lst ) {
	depth[u] = depth[lst] + 1, kfa[u][0] = lst;
	for ( int i = 1; i <= 20; ++ i )	kfa[u][i] = kfa[kfa[u][i - 1]][i - 1];
	for ( int i = begin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
	}
}

int calcLCA ( int u, int v ) {
	if ( depth[u] < depth[v] )	swapp ( u, v );
	for ( int i = 20; ~ i; -- i ) {
		if ( depth[kfa[u][i]] >= depth[v] )	u = kfa[u][i];
	}
	if ( u == v )	return u;
	for ( int i = 20; ~ i; -- i ) {
		if ( kfa[u][i] != kfa[v][i] )	u = kfa[u][i], v = kfa[v][i];
	}
	return kfa[u][0];
}

void Upt ( const int x ) { nodes[x].val = nodes[nodes[x].lch].val + nodes[nodes[x].rch].val; }
void Modify ( int &x, const int l, const int r, const int segP, const int segW ) {
	if ( ! x )	x = ++ tot;
	if ( l == r )	return void ( nodes[x].val += segW );
	int mid = ( l + r ) >> 1;
	if ( mid >= segP )	Modify ( nodes[x].lch, l, mid, segP, segW );
	else	Modify ( nodes[x].rch, mid + 1, r, segP, segW );
	Upt ( x );
}

int Query ( const int x, const int l, const int r, const int segP ) {
	if ( l == r )	return nodes[x].val;
	int mid = ( l + r ) >> 1;
	if ( mid >= segP )	return Query ( nodes[x].lch, l, mid, segP );
	else	return Query ( nodes[x].rch, mid + 1, r, segP );
}

int Merge ( const int x, const int y, const int l, const int r ) {
	if ( ! x || ! y )	return x | y;
	if ( l == r )	return ( nodes[x].val += nodes[y].val, x );
	int mid = ( l + r ) >> 1;
	nodes[x].lch = Merge ( nodes[x].lch, nodes[y].lch, l, mid );
	nodes[x].rch = Merge ( nodes[x].rch, nodes[y].rch, mid + 1, r );
	Upt ( x );
	return x;
}

void Solve ( const int u, const int lst ) {
	for ( int i = begin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		Solve ( v, u );
		oneR[u] = Merge ( oneR[u], oneR[v], 1, upper );
		anotherR[u] = Merge ( anotherR[u], anotherR[v], 1, upper );
	}
	ans[u] = Query ( oneR[u], 1, upper, depth[u] + weight[u] ) + Query ( anotherR[u], 1, upper, weight[u] - depth[u] + n );
}

int main () {
	n = rint (), m = rint ();
	for ( int i = 1, u, v; i < n; ++ i ) {
		u = rint (), v = rint ();
		makeEdge ( u, v ), makeEdge ( v, u );
	}
	for ( int i = 1; i <= n; ++ i )	weight[i] = rint ();
	dfs ( 1, 0 );
	upper = ( n << 1 );
	for ( int i = 1, u, v; i <= m; ++ i ) {
		u = rint (), v = rint ();
		int x = calcLCA ( u, v );
		Modify ( oneR[u], 1, upper, depth[u], 1 );
		Modify ( oneR[x], 1, upper, depth[u], -1 );
		Modify ( anotherR[v], 1, upper, depth[u] - 2 * depth[x] + n, 1 );
		Modify ( anotherR[kfa[x][0]], 1, upper, depth[u] - 2 * depth[x] + n, -1 );
	}
	Solve ( 1, 0 );
	for ( int i = 1; i <= n; ++ i )	wint ( ans[i] ), putchar ( ' ' );
	return 0;
}
```

</details>

### POJ1222 ç†„ç¯æ¸¸æˆ

ç”¨ $m_{i,j}$ è¡¨ç¤ºç­”æ¡ˆï¼Œ$a_{i,j}$ è¡¨ç¤ºåŸçŸ©é˜µã€‚

åˆ™æ–¹ç¨‹ä¸º $(m_{i,j}+m_{i-1,j}+m_{i+1,j}+m_{i,j-1}+m_{i,j+1}+a_{i,j})\operatorname{bitand}1=0$ã€‚

å˜ä¸‹å½¢é«˜æ¶ˆå³å¯ã€‚

<details>

```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 50;

template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

int mat[MAXN][MAXN], ori[MAXN][MAXN];
int wax[5] = { 0, 0, 0, 1, -1 }, way[5] = { 0, 1, -1, 0, 0 };

int has ( const int x, const int y ) { return ( x - 1 ) * 6 + y; }

void Eradicate () {
	for ( int i = 1; i <= 30; ++ i ) {
		int p = i;
		for ( int j = i + 1; j <= 30; ++ j ) {
			if ( mat[p][i] < mat[j][i] )	p = j;
		}
		for ( int j = 1; j <= 31; ++ j )	swapp ( mat[p][j], mat[i][j] );
		for ( int j = 1; j <= 30; ++ j ) {
			if ( i == j || ! mat[j][i] )	continue;
			for ( int k = 1; k <= 31; ++ k )	mat[j][k] ^= mat[i][k];
		}
	}
}

int main () {
	int cases; scanf ( "%d", &cases );
	for ( int _ = 1; _ <= cases; ++ _ ) {
		memset( mat, 0, sizeof ( mat ) );
		for ( int i = 1; i <= 5; ++ i ) {
			for ( int j = 1; j <= 6; ++ j )	scanf ( "%d", &ori[i][j] );
		}
		for ( int i = 1; i <= 5; ++ i ) {
			for ( int j = 1; j <= 6; ++ j ) {
				for ( int k = 0; k < 5; ++ k ) {
					int nxi = i + wax[k], nxj = j + way[k];
					if ( nxi >= 1 && nxi <= 5 && nxj >= 1 && nxj <= 6 )	mat[has ( i, j )][has ( nxi, nxj )] = 1;
				}
				mat[has ( i, j )][31] = ori[i][j];
			}
		}
		Eradicate ();
		printf ( "PUZZLE #%d\n", _ );
		for ( int i = 1; i <= 5; ++ i ) {
			for ( int j = 1; j <= 6; ++ j )	printf ( "%d ", mat[has ( i, j )][31] );
			putchar ( '\n' );
		}
	}
	return 0;
}
```

</details>

### P2973 [USACO10HOL]Driving Out the Piggies G

ç›´æ¥è®¾æ¦‚ç‡åšä¸æ¥çš„æ ·å­ã€‚ã€‚ã€‚

é—®äº†ä¸€ä¸‹æ‡‚è¡Œçš„äººå‘ç°éœ€è¦è®¾æœŸæœ›ã€‚

è®¾ $f_{u}$ ä¸ºèŠ‚ç‚¹ç»è¿‡ $u$ çš„æœŸæœ›æ¬¡æ•°ï¼Œè®¾ $E$ ä¸ºè¾¹é›†ï¼Œ$d_{u}$ è¡¨ç¤ºèŠ‚ç‚¹ $u$ çš„åº¦ã€‚
$$
f_{u}=(1-\frac{p}{q})\sum_{(u,v)\in E}\frac{1}{d_{v}}f_{v}
$$
å› ä¸ºæœ‰ç¯ï¼Œæ‰€ä»¥éœ€è¦é«˜æ–¯æ¶ˆå…ƒä¸€ä¸‹ã€‚

é‚£ä¹ˆåœ¨æ¯ä¸ªèŠ‚ç‚¹çˆ†ç‚¸çš„æ¦‚ç‡å³ä¸º $f_{u}\times\frac{p}{q}$ã€‚

æ€»ç»“ä¸€ä¸‹ï¼Œè¿™é“é¢˜å‘Šè¯‰äº†æˆ‘ä¸ä»…æ˜¯æœŸæœ›å¯ä»¥å›å½’æœ¬è´¨ç”¨æ¦‚ç‡æï¼Œæ¦‚ç‡ä¹Ÿå¯ä»¥ç”¨æœŸæœ›æ¥æ•´ã€‚

<details>

```cpp
#include <cstdio>

const int MAXN = 300 + 5, MAXM = MAXN * MAXN;

template<typename _T> _T ABS ( const _T x ) { return x > 0 ? x : -x; }
template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = x; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXM];

int n, m, p, q, cnt, d[MAXN], begin[MAXN];
double mat[MAXN][MAXN], sol[MAXN], boomed, transed;

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, begin[u] ), begin[u] = cnt; }

void Eradicate () {
	for ( int i = 1; i <= n; ++ i ) {
		int p = i;
		for ( int j = i + 1; j <= n; ++ j ) {
			if ( ABS ( mat[p][i] ) < ABS ( mat[j][i] ) )	p = j;
		}
		for ( int j = 1; j <= n + 1; ++ j )	swapp ( mat[p][j], mat[i][j] );
		for ( int j = 1; j <= n; ++ j ) {
			if ( i == j )	continue;
			double d = mat[j][i] / mat[i][i];
			for ( int k = 1; k <= n + 1; ++ k )	mat[j][k] -= mat[i][k] * d;
		}
	}
	for ( int i = 1; i <= n; ++ i )	sol[i] = mat[i][n + 1] / mat[i][i];
}

int main () {
	scanf ( "%d%d%d%d", &n, &m, &p, &q );
	for ( int i = 1, u, v; i <= m; ++ i ) {
		scanf ( "%d%d", &u, &v );
		makeEdge ( u, v ), makeEdge( v, u );
		d[u] ++, d[v] ++;
	}
	boomed = ( double )p / ( double )q;
	transed = 1 - boomed;
	for ( int _ = 1; _ <= n; ++ _ ) {
		int u = _;
		mat[u][u] = 1;
		for ( int i = begin[u]; i; i = as[i].nx ) {
			int v = as[i].to;
			mat[u][v] -= transed / d[v];
		}
	}
	mat[1][n + 1] = 1;
	Eradicate ();
	for ( int i = 1; i <= n; ++ i )	printf ( "%.9lf\n", sol[i] * boomed );
	return 0;
}
```

</details>

### CF113D Museum

è®¾ $f_{u,v}$ è¡¨ç¤ºåŒä¸€æ—¶åˆ» Petya åœ¨ç‚¹ $u$ï¼ŒVasya åœ¨ç‚¹ $v$ çš„æ¦‚ç‡ã€‚
$$
f_{u,v}=p_{u}p_{v}f_{u,v}+\sum_{(u,u')\in E}\sum_{(v,v')\in E}\frac{1-p_{u'}}{d_{u'}}\frac{1-p_{v'}}{d_{v'}}f_{u',v'}+\sum_{(u,u')\in E}p_{v}\frac{1-p_{u'}}{d_{v'}}f_{u',v}+\sum_{(v,v')\in E}p_{u}\frac{1-p_{v'}}{d_{v'}}f_{u,v'}
$$
å®Œäº†ã€‚

<details>

```cpp
#include <cstdio>

const double EPS = 1e-8;
const int MAXN = 500 + 5, MAXM = MAXN * MAXN;

template<typename _T> _T ABS ( const _T x ) { return x > 0 ? x : -x; }
template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXM];

int n, m, s, t, cnt, upper, d[MAXN], begin[MAXN];
double mat[MAXN][MAXN], p[MAXN];

int has ( const int x, const int y ) { return ( x - 1 ) * n + y; }
void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, begin[u] ), begin[u] = cnt; }

void Eradicate () {
	for ( int i = 1; i <= upper; ++ i ) {
		int p = i;
		for ( int j = i + 1; j <= upper; ++ j ) {
			if ( ABS ( mat[p][i] ) < ABS ( mat[j][i] ) )	p = i;
		}
		for ( int j = i + 1; j <= upper + 1; ++ j )	swapp ( mat[p][j], mat[i][j] );
		if ( ABS ( mat[i][i] ) < EPS )	continue;
		for ( int j = 1; j <= upper; ++ j ) {
			if ( i == j )	continue;
			double d = mat[j][i] / mat[i][i];
			for ( int k = 1; k <= upper + 1; ++ k )	mat[j][k] -= mat[i][k] * d;
		}
	}
	for ( int i = 1; i <= upper; ++ i )	mat[i][upper + 1] /= mat[i][i];
}

int main () {
	scanf ( "%d%d%d%d", &n, &m, &s, &t ), upper = n * n;
	for ( int i = 1, u, v; i <= m; ++ i ) {
		scanf ( "%d%d", &u, &v );
		makeEdge ( u, v ), makeEdge ( v, u );
		d[u] ++, d[v] ++;
	}
	for ( int i = 1; i <= n; ++ i )	scanf ( "%lf", &p[i] );
	for ( int i = 1; i <= n; ++ i ) {
		for ( int j = 1; j <= n; ++ j ) {
			if ( i == j )	mat[has ( i, j )][has ( i, j )] = 1;
			else	mat[has ( i, j )][has ( i, j )] = 1 - p[i] * p[j];
			for ( int ii = begin[i]; ii; ii = as[ii].nx ) {
				int u = as[ii].to;
				for ( int iii = begin[j]; iii; iii = as[iii].nx ) {
					int v = as[iii].to;
					if ( u == v )	continue;
					mat[has ( i, j )][has ( u, v )] = -( 1 - p[u] ) / d[u] * ( 1 - p[v] ) / d[v];
				}
			}
			for ( int ii = begin[i]; ii; ii = as[ii].nx ) {
				int u = as[ii].to;
				if ( u == j )	continue;
				mat[has ( i, j )][has ( u, j )] = -p[j] * ( 1 - p[u] ) / d[u];
			}
			for ( int ii = begin[j]; ii; ii = as[ii].nx ) {
				int v = as[ii].to;
				if ( i == v )	continue;
				mat[has ( i, j )][has ( i, v )] = -p[i] * ( 1 - p[v] ) / d[v];
			}
		}
	}
	mat[has ( s, t )][upper + 1] = 1;
	Eradicate ();
	for ( int i = 1; i <= n; ++ i )	printf ( "%.9lf ", mat[has ( i, i )][upper + 1] );
	return 0;
}
```

</details>

### CF652E Pursuit For Artifacts - AC

ç¼©ä¸ªç‚¹æ²¡äº†ã€‚

<details>

```cpp
#include <queue>
#include <cstdio>
#include <cstdlib>
#define begin DEFAR1

using namespace std;

const int MAXN = 3e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T> _T MIN ( const _T x, const _T y ) { return x < y ? x : y; }

struct GraphSet {
	int to, nx, wt;
	GraphSet ( int T = 0, int N = 0, int W = 0 ) { to = T, nx = N, wt = W; }
} as[MAXN * 2];

struct EdgeSet {
	int nx, wt;
	EdgeSet ( int N = 0, int W = 0 ) { nx = N, wt = W; }
};

vector<EdgeSet> newG[MAXN];
int n, m, s, t, cnt, sjc, dfn[MAXN], low[MAXN], top, stk[MAXN], begin[MAXN], vis[MAXN], col, bel[MAXN], pnt[MAXN], ind[MAXN];

void makeEdge ( const int u, const int v, const int w ) { as[++ cnt] = GraphSet ( v, begin[u], w ), begin[u] = cnt; }

void dfs ( const int u, const int lst ) {
	vis[u] = 1, stk[++ top] = u;
	dfn[u] = ++ sjc, low[u] = sjc;
	for ( int i = begin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		if ( ! dfn[v] )	dfs ( v, u ), low[u] = MIN ( low[u], low[v] );
		else if ( vis[v] )	low[u] = MIN ( low[u], dfn[v] );
	}
	if ( low[u] == dfn[u] ) {
		int v = 0; col ++;
		while ( u != v )	v = stk[top --], vis[v] = 0, bel[v] = col;
	}
}

void solve ( const int u, int ans ) {
	if ( pnt[u] )	ans = 1;
	if ( u == t ) {
		if ( ans )	printf ( "YES\n" );
		else	printf ( "NO\n" );
		exit ( 0 );
	}
	ind[u] = 1;
	for ( unsigned i = 0; i < newG[u].size (); ++ i ) {
		int v = newG[u][i].nx, w = newG[u][i].wt;
		if ( ind[v] )	continue;
		solve ( v, ans | w );
	}
}

int main () {
	n = rint (), m = rint ();
	for ( int i = 1, u, v, w; i <= m; ++ i ) {
		u = rint (), v = rint (), w = rint ();
		makeEdge ( u, v, w ), makeEdge ( v, u, w );
	}
	dfs ( 1, 0 );
	for ( int _ = 1; _ <= n; ++ _ ) {
		int u = _;
		for ( int i = begin[u]; i; i = as[i].nx ) {
			int v = as[i].to, w = as[i].wt;
			if ( bel[u] == bel[v] ) { pnt[bel[u]] |= w; continue; }
			newG[bel[u]].push_back ( EdgeSet ( bel[v], w ) );
			newG[bel[v]].push_back ( EdgeSet ( bel[u], w ) ); 
		}
	}
	s = rint (), t = rint (), s = bel[s], t = bel[t];
	solve ( s, 0 );
	return 0;
}
```

</details>

### P6807 [BalticOI 2010 Day2] Matching Bins

æ³¨æ„åˆ°å€¼åŸŸä¹˜èŒƒå›´åˆšå¥½èƒ½è¿‡ã€‚

ç„¶åå°±å­˜ä¸¤ä¸ªæ¡¶å³å¯ã€‚ã€‚ã€‚ï¼ˆæ•°ç»„å¼€å°é£äº†åŠå¤©æ‰è°ƒå‡ºæ¥ã€‚ã€‚ã€‚ï¼‰

<details>

```cpp
#include <cstdio>

const int MAXN = 2e4 + 5, MAXM = 1e3 + 5;

int n, m, a[MAXN], oneB[MAXM], anotherB[MAXN];

int main () {
	scanf ( "%d%d", &m, &n );
	for ( int i = 1; i <= n; ++ i )	scanf ( "%d", &a[i] );
	int ans = 0;
	for ( int i = 1; ( i << 1 ) <= n; ++ i ) {
		oneB[a[i]] ++;
		for ( int j = i + 1; j <= ( i << 1 ); ++ j )	anotherB[a[j] - 1] ++;
		int oneR = 0, anotherR = 0, suc = 1;
		for ( int j = 0; j <= m; ++ j ) {
			oneR += oneB[j], anotherR += anotherB[j];
			if ( oneR < anotherR ) { suc = 0; break; }
		}
		for ( int j = i + 1; j <= ( i << 1 ); ++ j )	anotherB[a[j] - 1] --;
		if ( suc )	ans = i;
	}
	printf ( "%d\n", ans );
	return 0;
}
```

</details>

### CF414C Mashmokh and Reverse Operation

è€ƒè™‘ä¸€æ¬¡åè½¬åå¯¹æ•´ä¸ªåºåˆ—é€ æˆçš„å½±å“ã€‚

æ¯æ¬¡æ“ä½œç›¸å½“äºæŠŠæ•´ä¸ªåºåˆ—åˆ†æˆäº† $2^{n-q}$ ä¸ªå—ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘å—å†…å’Œå—å¤–ã€‚

è€ƒè™‘ä¸€ä¸ªå—å¯¹å…¶ä»–å—çš„æƒ…å†µã€‚

å—¯ã€‚

æ²¡æœ‰å½±å“ï¼Œå®Œã€‚

é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è€ƒè™‘å¦‚ä½•å¿«é€Ÿè®¡ç®—å‡ºæ¯ä¸ªå—å†…çš„å˜åŒ–å³å¯ã€‚

åƒå½’å¹¶æ’åºä¸€æ ·è€ƒè™‘é—®é¢˜ï¼ŒæŠŠåºåˆ—åˆ†æˆ $n$ å±‚ï¼ˆæŠŠäºŒå‰æ ‘ç”»å‡ºæ¥ï¼‰ã€‚

è¦åè½¬åŒºé—´ $[l,r]$ å°±è¦ç¿»è½¬ $[l,m],[m+1,r],m=\lfloor\frac{l+r}{2}\rfloor$ï¼Œä»¥æ­¤ç±»æ¨ã€‚

ç„¶åå°±é¢„å¤„ç†å‡ºæ¯ä¸€å±‚é¡ºåºå¯¹é€†åºå¯¹å³å¯ã€‚

<details>

```cpp
#include <cstdio>
#define LL long long

const int MAXN = ( 1 << 20 ) + 5, MAXM = 1e6 + 5;

LL rint () {
	LL x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

int n, m, ts, a[MAXN], fm[MAXN];
LL cnt[25][2];

void Merge ( const int l, const int r, const int x ) {
	if ( l >= r )	return;
	int mid = ( l + r ) >> 1;
	Merge ( l, mid, x - 1 ), Merge ( mid + 1, r, x - 1 );
	int i = l, j = mid + 1;
	for ( ; i <= mid && j <= r; ) {
		if ( a[i] < a[j] )	cnt[x][1] += r - j + 1, ++ i;
		else	++ j;
	}
	i = l, j = mid + 1;
	int s = 0;
	for ( ; i <= mid && j <= r; ) {
		if ( a[i] > a[j] )	cnt[x][0] += mid - i + 1, fm[s ++] = a[j ++];
		else	fm[s ++] = a[i ++];
	}
	for ( ; i <= mid; fm[s ++] = a[i ++] ) ;
	for ( ; j <= r; fm[s ++] = a[j ++] ) ;
	for ( int i = l; i <= r; ++ i )	a[i] = fm[i - l];
}

int main () {
	n = rint ();
	for ( int i = 1; i <= ( 1 << n ); ++ i )	a[i] = rint ();
	Merge ( 1, 1 << n, n );
	m = rint ();
	for ( int _ = 1; _ <= m; ++ _ ) {
		int x = rint ();
		LL res = 0;
		while ( x -- > 0 )	swapp ( cnt[x + 1][0], cnt[x + 1][1] );
		for ( int i = 1; i <= n; ++ i )	res += cnt[i][0];
		wint ( res ), putchar ( '\n' );
	}
	return 0;
}
```

</details>

### LOC25917 æœ€å¤§Kæ®µå’Œ

[Desc. & Link.](http://222.180.160.110:1024/problem/25917)

æš´åŠ›ä¸º $\Theta(NK)$ã€‚

æ­£è§£ï¼ˆä¹Ÿè®¸ï¼‰ï¼š

æŠŠæ¯ä¸€ä¸ªå…¨ä¸ºæ­£æ•´æ•°çš„å­æ®µæ‰¾å‡ºæ¥ã€‚

ç„¶ååˆ¤æ–­ä¸€ä¸‹ä¸­é—´è¿æ¥çš„æƒ…å†µå³å¯ã€‚

ä½†æ˜¯è¿™æ ·å†³ç­–æƒ…å†µå¤ªå¤šäº†ã€‚

æˆ‘ä»¬éœ€è¦è€ƒè™‘è´ªå¿ƒã€‚

æŠŠæ‰€æœ‰æ•´æ•°æ®µçš„ä¸ªæ•°è®°ä¸º $totP$ï¼Œæ¯ä¸ªå­æ®µçš„åŒºé—´è®°ä¸º $[posL_{i},posR_{i}]$ï¼ŒåŒºé—´å’Œè®°ä¸º $sumP_{i}$

æŠŠå…¶ä»–çš„è´Ÿæ•°æ®µä¸ªæ•°è®°ä¸º $totN$ï¼ŒåŒºé—´å’Œè®°ä¸º $sumN_{i}$ã€‚

å½“ $totP\le k$ ç­”æ¡ˆæ˜¾ç„¶ã€‚

æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„æ˜¯ $totP>k$ çš„æƒ…å†µã€‚

æˆ‘ä»¬æŠŠæ•´æ•°æ®µã€è´Ÿæ•°æ®µç¼©æˆç‚¹ã€‚

ç„¶åé—®é¢˜è¿˜æ˜¯æœ€å¤šé€‰ $k$ æ®µçš„æœ€å¤§å­æ®µå’Œã€‚

ä¸è¿‡æˆ‘ä»¬çš„åºåˆ—æœ‰ä¸ªæ€§è´¨ï¼šç›¸é‚»æ•°çš„æ­£è´Ÿæ€§ä¸åŒã€‚ï¼ˆguï¼‰

å¥½äº†æ”¾å¼ƒä»¥ä¸Šæƒ³æ³•ã€‚

æ¨¡æ‹Ÿ $k$ è½®æ‰¾å…¨å±€æœ€å¤§å­æ®µå’Œï¼Œæ‰¾åˆ°ä¸€æ¬¡æŠŠå­æ®µä¹˜ä¸Š $-1$ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x < y ? y : x; }
template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

struct nodeS {
	LL val, dat, p, s;
	int l, r, pl, pr, sl, sr;
	nodeS ( LL V = 0, LL D = 0, LL P = 0, LL S = 0,
			int L = 0, int R = 0, int Pl = 0, int Pr = 0, int Sl = 0, int Sr = 0 ) {
				val = V, dat = D, p = P, s = S, l = L, r = R, pl = Pl, pr = Pr, sl = Sl, sr = Sr; }
} nodes[MAXN * 4][2];

int n, k, a[MAXN];
bool tag[MAXN * 4];

nodeS Merge ( const nodeS lch, const nodeS rch ) {
	nodeS ret;
	ret.val = lch.val + rch.val;
	ret.p = MAX ( lch.p, lch.val + rch.p );
	if ( ret.p == lch.p )	ret.pl = lch.pl, ret.pr = lch.pr;
	else	ret.pl = lch.pl, ret.pr = rch.pr;
	ret.s = MAX ( rch.s, rch.val + lch.s );
	if ( ret.s == rch.s )	ret.sl = rch.sl, ret.sr = rch.sr;
	else	ret.sl = lch.sl, ret.sr = rch.sr;
	ret.dat = MAX ( lch.s + rch.p, MAX ( lch.dat, rch.dat ) );
	if ( ret.dat == lch.dat )	ret.l = lch.l, ret.r = lch.r;
	else if ( ret.dat == rch.dat )	ret.l = rch.l, ret.r = rch.r;
	else	ret.l = lch.sl, ret.r = rch.pr;
	return ret;
}

void Upt ( const int x ) {
	nodes[x][0] = Merge ( nodes[x << 1][0], nodes[x << 1 | 1][0] );
	nodes[x][1] = Merge ( nodes[x << 1][1], nodes[x << 1 | 1][1] );
}

void Spr ( const int x ) {
	if ( ! tag[x] )	return;
	swapp ( nodes[x << 1][0], nodes[x << 1][1] );
	swapp ( nodes[x << 1 | 1][0], nodes[x << 1 | 1][1] );
	tag[x << 1] ^= 1, tag[x << 1 | 1] ^= 1, tag[x] = 0;
}

void Build ( const int x, const int l, const int r ) {
	if ( l == r ) {
		nodes[x][0] = nodeS ( a[l], a[l], a[l], a[l], l, l, l, l, l, l );
		nodes[x][1] = nodeS ( -a[l], -a[l], -a[l], -a[l], l, l, l, l, l, l );
		return;
	}
	int mid = ( l + r ) >> 1;
	Build ( x << 1, l, mid );
	Build ( x << 1 | 1, mid + 1, r );
	Upt ( x );
}

void Modify ( const int x, const int l, const int r, const int segL, const int segR ) {
	if ( l > segR || r < segL )	return;
	if ( l >= segL && r <= segR ) {
		swapp ( nodes[x][0], nodes[x][1] );
		tag[x] ^= 1;
		return;
	}
	int mid = ( l + r ) >> 1;
	Spr ( x );
	Modify ( x << 1, l, mid, segL, segR );
	Modify ( x << 1 | 1, mid + 1, r, segL, segR );
	Upt ( x );
}

int main () {
	n = rint (), k = rint ();
	for ( int i = 1; i <= n; ++ i )	a[i] = rint ();
	Build ( 1, 1, n );
	LL ans = 0;
	while ( k -- > 0 ) {
		nodeS ret = nodes[1][0];
		if ( ret.dat < 0 )	break;
		Modify ( 1, 1, n, ret.l, ret.r );
		ans += ret.dat;
	}
	wint ( ans ), putchar ( '\n' );
	return 0;
}
```

</details>

### LOC25918 åŒç«¯é˜Ÿåˆ—xLISé—®é¢˜ - AC

[Desc. & Link.](http://222.180.160.110:1024/problem/25918)

è®¾ $f_{i,0/1}$ è¡¨ç¤ºæŠŠ $a_{i}$ å¾€å¤´/å°¾æ”¾å¯ä»¥å¾—åˆ°çš„æœ€å¤šçš„ä¸Šå‡å­åºåˆ—ã€‚
$$
f_{i,0}=\begin{cases}\max\{f_{j,0},f_{j,1}\}+1,a_{i}<a_{j} \\\max\{f_{j,0},f_{j,1}\},a_{i}\ge a_{j}\end{cases} \\f_{i,1}=\begin{cases}\max\{f_{j,0},f_{j,1}\},a_{i}<a_{j} \\\max\{f_{j,0},f_{j,1}\}+1,a_{i}\ge a_{j}\end{cases}
$$
ä¸è¡Œã€‚

è€ƒè™‘æ™®é€šçš„ LIS æ€ä¹ˆåšã€‚
$$
f_{i}=\max\{f_{j}\}+1,a_{i}>a_{j}
$$

$$
a_{i}<a_{j},i<j
$$

é€‰æ‹©å¾€å‰æ”¾çš„å…ƒç´ ï¼Œæ”¾å¾—è¶Šæ™šè¶Šé å‰ã€‚

é€‰æ‹©å¾€åæ”¾çš„å…ƒç´ ï¼Œæ”¾å¾—è¶Šæ™šè¶Šé åã€‚

é‚£ä¹ˆéœ€è¦åšçš„æ˜¯æŠŠç›¸å¯¹è¾ƒå¤§çš„å…ƒç´ å¾€åï¼Œç›¸å¯¹è¾ƒå°çš„å…ƒç´ å¾€å‰ã€‚

è¿è¾¹ï¼ŒæŠŠæä¸‰èŠ±åçš„ $a_{i}$ è¿å‘ $\text{trans}(i,0),\text{trans}(i,1),\text{trans}(x,0/1)=n-x+1/x+n$ã€‚

<details>

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 2e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x < y ? y : x; }

struct Value {
	int val, pos;
	Value ( int V = 0, int P = 0 ) { val = V, pos = P; }
	bool operator < ( const Value &another ) { return val < another.val; }
} vals[MAXN];

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, cnt, len, degin[MAXN], a[MAXN], b[MAXN], buc[MAXN], sywf[MAXN];

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, degin[u] ), degin[u] = cnt; }
int Trans ( const int x, const int y ) { return ! y ? n - x + 1 : x + n; }

void ADD ( int p, const int x ) { for ( ; p <= ( n << 1 ); p += p & -p )	sywf[p] = MAX ( sywf[p], x ); }
int ASK ( int p ) { int res = 0; for ( ; p; p -= p & -p )	res = MAX ( res, sywf[p] ); return res; }
int CMP ( const int x, const int y ) { return x > y; }

int main () {
//	freopen ( "dequexlis.in", "r", stdin );
//	freopen ( "dequexlis.out", "w", stdout );
	n = rint ();
	for ( int i = 1; i <= n; ++ i )	a[i] = b[i] = rint ();
	sort ( b + 1, b + 1 + n );
	len = unique ( b + 1, b + 1 + n ) - b - 1;
	for ( int i = 1; i <= n; ++ i )	a[i] = lower_bound ( b + 1, b + 1 + len, a[i] ) - b;
	for ( int i = 1; i <= n; ++ i )	vals[i] = Value ( a[i], i );
	for ( int i = 1; i <= n; ++ i ) {
		makeEdge ( a[i], Trans ( i, 0 ) );
		makeEdge ( a[i], Trans ( i, 1 ) );
	}
	int BUC = 0;
	for ( int x_x = 1; x_x <= n; ++ x_x ) {
		int u = x_x;
		BUC = 0;
		for ( int i = degin[u]; i; i = as[i].nx ) {
			int v = as[i].to;
			buc[++ BUC] = v;
		}
		sort ( buc + 1, buc + 1 + BUC, CMP );
		for ( int i = 1; i <= BUC; ++ i )	ADD ( buc[i], 1 + ASK ( buc[i] - 1 ) );
	}
	wint ( ASK ( n << 1 ) ), putchar ( '\n' );
	return 0;
}

/* Jesus bless all */
```

</details>

### LOC25915 è§‚å¯Ÿ - AC

[Desc. & Link.](http://222.180.160.110:1024/problem/25915)

DFN ä¸€ä¸‹åˆ¤æ–­å®Œäº†ã€‚

<details>

```cpp
#include <set>
#include <cstdio>

using namespace std;

const int MAXN = 800000 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN *2];

set<int> S;
int n, m, cnt, sjc, degin[MAXN], kfa[MAXN][25], depth[MAXN], fur[MAXN], ord[MAXN], seg[MAXN];

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, degin[u] ), degin[u] = cnt; }

void dfs ( const int u, const int lst ) {
	ord[u] = ++ sjc, depth[u] = depth[lst] + 1;
	seg[sjc] = u, kfa[u][0] = lst;
	for ( int i = 1; i <= 20; ++ i )	kfa[u][i] = kfa[kfa[u][i - 1]][i - 1];
	for ( int i = degin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u ), fur[u] += fur[v];
	}
}

int calcLCA ( int u, int v ) {
	if ( depth[u] < depth[v] )	swapp ( u, v );
	for ( int i = 20; ~ i; -- i ) {
		if ( depth[kfa[u][i]] >= depth[v] )	u = kfa[u][i];
	}
	if ( u == v )	return u;
	for ( int i = 20; ~ i; -- i ) {
		if ( kfa[u][i] != kfa[v][i] )	u = kfa[u][i], v = kfa[v][i];
	}
	return kfa[u][0];
}

int main () {
	n = rint (), m = rint ();
	for ( int i = 2, f; i <= n; ++ i )	f = rint (), makeEdge ( f, i );
	dfs ( 1, 0 ), depth[0] = -1;
	while ( m -- > 0 ) {
		int u = rint ();
		if ( u > 0 ) {
			if ( ! S.insert ( ord[u] ).second )	S.erase ( ord[u] );
			continue;
		}
		u = -u;
		if ( S.empty () )	wint ( 0 ), putchar ( '\n' );
		else {
			int one = 0, another = 0;
			auto pos = S.lower_bound ( ord[u] );
			if ( pos != S.end () )	one = calcLCA ( u, seg[* pos] );
			if ( pos != S.begin () )	another = calcLCA ( u, seg[* prev ( pos )] );
			if ( depth[one] >= depth[another] )	wint ( one ), putchar ( '\n' );
			else	wint ( another ), putchar ( '\n' );
		}
	}
	return 0;
}
```

</details>

### LOC25924 ZZHçš„æ¸¸æˆ - AC

[Desc. & Link.](http://222.180.160.110:1024/contest/1011/problem/1)

è¡Œèµ°çš„å½¢å¼æ˜¯æ¯”è¾ƒè‡ªç”±çš„ï¼Œå› ä¸ºåªè¦èµ°åˆ°äº†æœ€ä¼˜ç­”æ¡ˆå¤„å°±å¯ä»¥ä¸ç®¡äº†ï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘æ¸¸æˆçš„ç»“æŸã€‚

è€ƒè™‘äºŒåˆ†ç­”æ¡ˆã€‚

ç„¶åé¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹åˆ° $s$ï¼ˆå¦ä¸€æ£µæ ‘å°±æ˜¯ $t$ï¼‰çš„è·ç¦»ã€‚

åˆ¤æ–­ç­”æ¡ˆåˆæ³•æ€§ï¼š

é¦–å…ˆæšä¸¾ $A$ æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹ç¼–å·å°äºå½“å‰äºŒåˆ†çš„ç­”æ¡ˆï¼‰ï¼Œç„¶ååˆ¤æ–­éœ€è¦æ„æˆç­”æ¡ˆçš„ $B$ æ ‘ä¸Šçš„èŠ‚ç‚¹è·ç¦» $t$ çš„è·ç¦»çš„å¥‡å¶æ€§æ˜¯å¦ä¸€è‡´å³å¯ã€‚

ä½†æ˜¯è¿™æ ·æœ‰ä¸€ä¸ªé—®é¢˜ï¼šæˆ‘ä»¬å¦‚ä½•ç¡®ä¿è¿™ä¸ªç­”æ¡ˆæ˜¯æ•´ä¸ªä¸€è½®ç§»åŠ¨è¿‡ç¨‹ä¸­æœ€å¤§çš„ï¼Ÿ

ä»”ç»†è€ƒè™‘ä¸€ä¸‹ï¼Œæˆ‘ä»¬åˆ¤æ–­æˆåŠŸçš„ä¾æ®æ˜¯è¡Œèµ°è¿‡ç¨‹ä¸­æ‰€æœ‰å’Œä¸è¶…è¿‡æˆ‘ä»¬å½“å‰äºŒåˆ†çš„å€¼ï¼Œé‚£ä¹ˆè½¬ä¸ºåˆ¤æ–­è¿™ä¸ªé—®é¢˜ï¼ˆæ„æ€å°±æ˜¯å‰é¢é™æ™ºäº†ï¼‰ã€‚

å› ä¸ºè¿™æ˜¯ä¸€æ£µæ ‘ï¼Œæ‰€ä»¥è¯¥èµ°çš„è·¯å¾„ä¸€å®šä¼šèµ°ã€‚

å› ä¸ºæˆ‘ä»¬æšä¸¾äº† $A$ æ ‘ä¸­çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ¯æ¬¡ä»å“ªä¸¤ä¸ªèŠ‚ç‚¹èµ°åˆ° $s$ã€$t$ æ˜¯å›ºå®šä¸‹æ¥çš„ã€‚

è‰ï¼Œç›´æ¥ bfs åˆ¤æ–­æ‰¾å¯è¾¾æœ€å°å€¼å°±è¡Œäº†ã€‚

$\Theta(n\log_{2}^{2}n)$ï¼Œæˆ‘è§‰å¾—ä¸è¡Œï¼Œå…ˆå†™ã€‚

è‰å¡å¡å¸¸è¿‡äº†ã€‚

<details>

```cpp
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include <cstdio>
#include <queue>

using namespace std;

const int MAXN = 1e6 + 5;

namespace IO{
	const int sz=1<<22;
	char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
	inline char gc(){
		return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?EOF:*p1++):*p1++;
	}
	template<class T> void gi(T& x){
		x=0; char c=gc();
		for(;c<'0'||c>'9';c=gc());
		for(;c>='0'&&c<='9';c=gc())
			x=x*10+(c-'0');
	}
	inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
	inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
	template<class T> void pi(T x,char c='\n'){
		if(x==0) pc('0'); int t=0;
		for(;x;x/=10) p[++t]=x%10+'0';
		for(;t;--t) pc(p[t]); pc(c);
	}
	struct F{~F(){flush();}}f; 
}
using IO::gi;
using IO::pi;

template<typename _T> _T MIN ( const _T x, const _T y ) { return x < y ? x : y; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} asA[MAXN * 2], asB[MAXN * 2];

int n, s, t, cntA, cntB, beginA[MAXN], beginB[MAXN], disA[MAXN], disB[MAXN], visA[MAXN], visB[MAXN];

void makeEdgeA ( const int u, const int v ) { asA[++ cntA] = GraphSet ( v, beginA[u] ), beginA[u] = cntA; }
void makeEdgeB ( const int u, const int v ) { asB[++ cntB] = GraphSet ( v, beginB[u] ), beginB[u] = cntB; }

void dfsA ( const int u, const int lst, const int dis ) {
	disA[u] = dis;
	for ( int i = beginA[u]; i; i = asA[i].nx ) {
		int v = asA[i].to;
		if ( v == lst )	continue;
		dfsA ( v, u, dis + 1 );
	}
}

void dfsB ( const int u, const int lst, const int dis ) {
	disB[u] = dis;
	for ( int i = beginB[u]; i; i = asB[i].nx ) {
		int v = asB[i].to;
		if ( v == lst )	continue;
		dfsB ( v, u, dis + 1 );
	}
}

void behaveOneSide ( int ark, int& mnA, int& mnB, int& ord, priority_queue<int, vector<int>, greater<int>>& align ) {
	int preSave = mnA;
	while ( ! align.empty () ) {
		int u = align.top ();
		if ( u + mnB > ark )	break;
		else	align.pop ();
		for ( int i = beginA[u]; i; i = asA[i].nx ) {
			int v = asA[i].to;
			if ( visA[v] )	continue;
			visA[v] = 1, align.push ( v );
			mnA = MIN ( mnA, v );
		}
	}
	if ( mnA == preSave )	++ ord;
	else	ord = 0;
}

void behaveAnotherSide ( int ark, int& mnA, int& mnB, int& ord, priority_queue<int, vector<int>, greater<int>>& align ) {
	int preSave = mnB;
	while ( ! align.empty () ) {
		int u = align.top ();
		if ( u + mnA > ark )	break;
		else	align.pop ();
		for ( int i = beginB[u]; i; i = asB[i].nx ) {
			int v = asB[i].to;
			if ( visB[v] )	continue;
			visB[v] = 1, align.push ( v );
			mnB = MIN ( mnB, v );
		}
	}
	if ( mnB == preSave )	++ ord;
	else	ord = 0;
}

priority_queue<int, vector<int>, greater<int>> oneQ, anotherQ;
bool check ( const int x ) {
	for ( int i = 1; i <= n; ++ i )	visA[i] = visB[i] = 0;
	for ( ; ! oneQ.empty (); oneQ.pop () ) ;
	for ( ; ! anotherQ.empty (); anotherQ.pop () ) ;
	oneQ.push ( s ), anotherQ.push ( t );
	visA[s] = 1, visB[t] = 1;
	int turn = 0, mnA = s, mnB = t, ord = 0;
	while ( mnA > 1 || mnB > 1 ) {
		turn ^= 1;
		if ( turn )	behaveOneSide ( x, mnA, mnB, ord, oneQ );
		else	behaveAnotherSide ( x, mnA, mnB, ord, anotherQ );
		if ( ord > 2 )	break;
	}
	if ( mnA == 1 && mnB == 1 )	return 1;
	else	return 0;
}

int solve ( int l, int r ) {
	while ( l + 1 < r ) {
		int mid = ( l + r ) >> 1;
		if ( check ( mid ) )	r = mid;
		else	l = mid;
	}
	return r;
}

int main () {
	int tCase;
	gi ( tCase );
	while ( tCase -- > 0 ) {
		gi ( n ), cntA = cntB = 0;
		for ( int i = 1; i <= n; ++ i )	beginA[i] = 0, beginB[i] = 0;
		for ( int i = 1, u, v; i < n; ++ i ) {
			gi ( u ), gi ( v );
			makeEdgeA ( u, v ), makeEdgeA ( v, u );
		}
		for ( int i = 1, u, v; i < n; ++ i ) {
			gi ( u ), gi ( v );
			makeEdgeB ( u, v ), makeEdgeB ( v, u );
		}
		gi ( s ), gi ( t );
		// dfsA ( s, 0, 0 ), dfsB ( t, 0, 0 );
		pi ( solve ( 1, n << 1 ) );
	}
	return 0;
}
```

</details>

### LOC25927 ZZHä¸èƒŒåŒ… - AC

[Desc. & Link.](http://222.180.160.110:1024/contest/1011/problem/2)

$n$ å¾ˆå°ï¼Œ$q$ ä¹Ÿå¾ˆå°ã€‚

æ„Ÿè§‰è¿™ä¸ª $n$ ä¸æ˜¯ $2^{n}$ çš„ç®—æ³•ä¹Ÿä¸æ˜¯å¤šé¡¹å¼ç®—æ³•æ¬¸ã€‚

ä½†å¤æ‚åº¦ä¸€å®šä¸ $n$ æœ‰å…³â€¦â€¦

è‰è¿™ç©æ„å„¿æŠ˜åŠæ˜¯ä¸æ˜¯å¯ä»¥æŠ˜åŠæœç´¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥æœå‡ºä¸¤è¾¹æˆ‘ä»¬å¯ä»¥å‡‘å‡ºçš„ä»·æ ¼ï¼Œåˆ†åˆ«è®°ä¸º $A_{i},i\in[1,C_{A}]$ã€$B_{i},i\in[1,C_{B}]$ã€‚

ç„¶åè®© $A,B$ sortedã€‚

ç„¶åæšä¸¾ $A_{i}$ï¼Œæ‰¾åˆ° $B$ ä¸­æœ€å¤§çš„èƒ½ä¸ $A_{i}$ ç›¸åŠ å°äºç­‰äºéœ€è¦çš„å€¼ï¼Œç„¶åç®—ä¸‹è´¡çŒ®å³å¯ï¼ˆbullshitï¼‰ã€‚

ä¸æ˜¯ä¸ºä»€ä¹ˆç”¨å¿«è¯»æœ¬åœ°è¿‡æ•°æ®æäº¤ç“¦çˆ†å•Šã€‚ã€‚ã€‚

<details>

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
void read(long long &hhh)
{
	long long x=0;
	char c=getchar();
	while(((c<'0')|(c>'9'))&(c^'-'))	c=getchar();
	if(c^'-')	x=c^'0';
	char d=getchar();
	while((d>='0')&(d<='9'))
	{
		x=(x<<3)+(x<<1)+(d^'0');
		d=getchar();
	}
	if(c^'-')	hhh=x;
	else	hhh=-x;
}
void writing(long long x)
{
	if(!x)	return;
	if(x>9)	writing(x/10);
	putchar((x%10)^'0');
}
void write(long long x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	else if(!x)
	{
		putchar('0');
		putchar('\n');
		return;
	}
	writing(x);
	putchar('\n');
}
long long n,q,endone,beginano,onesiz,onebuc[2000005],anosiz,anobuc[2000005],opl,opr,cud[45];
void dfs(long long now,long long cur)
{
	if(now==endone+1)	onebuc[++onesiz]=cur;
	else
	{
		dfs(now+1,cur+cud[now]);
		dfs(now+1,cur);
	}
}
void exdfs(long long now,long long cur)
{
	if(now==n+1)	anobuc[++anosiz]=cur;
	else
	{
		exdfs(now+1,cur+cud[now]);
		exdfs(now+1,cur);
	}
}
long long solve(long long mos)
{
	long long now=anosiz;
	long long res=0;
	for(long long i=1;i<=onesiz;++i)
	{
		while(now&&onebuc[i]+anobuc[now]>mos)	now--;
		res+=now;
	}
	return res;
}
int main()
{
//	read(n);
//	read(q);
	scanf("%lld%lld",&n,&q);
//	for(long long i=1;i<=n;++i)	read(cud[i]);
	for(long long i=1;i<=n;++i)	scanf("%lld",&cud[i]);
	endone=(n>>1);
	beginano=endone+1;
	dfs(1,0);
	exdfs(beginano,0);
	sort(onebuc+1,onebuc+onesiz+1);
	sort(anobuc+1,anobuc+anosiz+1);
	while(q--)
	{
		scanf("%lld%lld",&opl,&opr);
//		read(opl);
//		read(opr);
//		write(solve(opr)-solve(opl-1));
		printf("%lld\n",solve(opr)-solve(opl-1));
	}
	return 0;
}
```

</details>

### LOC25929 ZZHçš„æ—…è¡Œ - IPï¼ˆç§‘æŠ€æ ‘æ²¡ç‚¹åˆ°ï¼‰

[Desc. & Link.](http://222.180.160.110:1024/contest/1011/problem/4)

ç›¸å½“äºåœ¨æ ‘ä¸Šå¯¹äºæ¯ä¸€ä¸ªç‚¹æ‰¾å‡ºæ‰¾å‡ºä¸€æ¡ä»¥å…¶ä¸ºé“¾é¡¶çš„é“¾ã€‚

è®¾ $f_{u}$ ä¸º $u$ çš„ç­”æ¡ˆã€‚
$$
f_{u}=\max_{v\in\text{son}(u)}\{f_{v}+(a_{u}-\text{dis}(u,v))\times b_{v},0\}
$$


æœ‰ä¹˜æ³•ï¼Œç„¶åé¢˜ç›®ä¸­ä¸€å †å¸¸æ•°ã€‚

:-) æ–œç‡ä¼˜åŒ–

æˆ‘ä»¬ä»¤ $s_{u}=\text{dis}(1,u)$ï¼Œç„¶å
$$
\begin{aligned}
f_{u}
&=\max_{v\in\text{son}(u)}\{f_{v}+(a_{u}+s_{u}-s_{v})\times b_{v},0\} \\
&=\max_{v\in\text{son}(u)}\{(a_{u}-s_{u})\times b_{v}+f_{v}-s_{v}\times b_{v},0\}
\end{aligned}
$$
ä»¤ $y=f_{u},x=a_{u}-s_{u},k=b_{v},b=f_{v}-s_{v}\times b_{v}$ï¼Œé‚£ä¹ˆè¿™ä¸ªä¸œè¥¿å°±æ˜¯ä¸€ä¸ª $y=kx+b$ã€‚

é‚£ä¹ˆæˆ‘ä»¬ç°åœ¨éœ€è¦åœ¨å­æ ‘é‡Œç»´æŠ¤å‡¸åŒ…ï¼Œå¹¶ä¸”èƒ½å¤Ÿæ”¯æŒåˆå¹¶å‡¸åŒ…å’Œæ’å…¥ç›´çº¿ã€‚

### CF1436D Bandit in a City - AC

å…ˆè€ƒè™‘äºŒåˆ†ç­”æ¡ˆï¼Œè®¾å½“å‰äºŒåˆ†çš„ç­”æ¡ˆä¸º $x$ã€‚

è€ƒè™‘å¦‚ä½•åˆ¤æ–­ã€‚

æˆ‘ä»¬æšä¸¾æ¯ä¸€ä¸ªå¶èŠ‚ç‚¹ï¼ˆè¿™é‡Œè®¾ $\text{subtree}(u)$ ä¸­çš„å¶èŠ‚ç‚¹é›†åˆä¸º $V_{l}(u)$ï¼Œéå¶èŠ‚ç‚¹é›†åˆä¸º $V_{f}(u)$ï¼‰ï¼Œè®¾å½“å‰æšä¸¾åˆ°äº† $u$ï¼Œé‚£ä¹ˆ $x$ è¿™ä¸ªå€¼å¯è¡Œçš„æ¡ä»¶ä¸ºï¼š

1. $a_{u}$ æœ¬èº« $\le x$ã€‚
2. å¯¹äº $\forall i,i'\in V_{l}(i),i''\in V_{f}(i)$ï¼Œæ»¡è¶³ $\sum a_{i'}+a_{i''}\le x\times|V_{l}(i)|$ã€‚

é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥äºŒåˆ†äº†ã€‚

æ³¨æ„ä¸€ä¸‹å˜é‡ç±»å‹ï¼ˆå°å‘ï¼‰ã€‚

<details>

```cpp
#include<cstdio>
int n,cntot,val[200005],begin[200005],to[200005],nxt[200005],onesiz[200005],anosiz[200005];
unsigned long long subcost[200005];
void read(int &hhh)
{
	int x=0;
	char c=getchar();
	while((c<'0'||c>'9')&&c^'-')	c=getchar();
	if(c^'-')	x=c^'0';
	char d=getchar();
	while(d>='0'&&d<='9')
	{
		x=(x<<3)+(x<<1)+(d^'0');
		d=getchar();
	}
	if(c^'-')	hhh=x;
	else	hhh=-x;
}
void writing(unsigned long long x)
{
	if(!x)	return;
	if(x>9)	writing(x/10);
	putchar((x%10)^'0');
}
void write(unsigned long long x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	else if(!x)
	{
		putchar('0');
		putchar('\n');
		return;
	}
	writing(x);
	putchar('\n');
}
void dfs(int u)
{
	onesiz[u]=1;
	if(!begin[u])	anosiz[u]=1;
	subcost[u]=val[u];
	for(int i=begin[u];i;i=nxt[i])
	{
		int v=to[i];
		dfs(v);
		onesiz[u]+=onesiz[v];
		anosiz[u]+=anosiz[v];
		subcost[u]+=subcost[v];
	}
}
bool check(unsigned long long cur)
{
	for(int i=1;i<=n;++i)
	{
		double one=subcost[i],ano=anosiz[i];
		if(one/ano>(double)cur)	return 0;
	}
	return 1;
}
long long search(long long l,long long r)
{
	long long res=0;
	while(l<=r)
	{
		long long mid=(l+r)>>1;
		if(check(mid))
		{
			r=mid-1;
			res=mid;
		}
		else	l=mid+1;
	}
	return res;
}
int main()
{
	read(n);
	for(int i=2;i<=n;++i)
	{
		int f;
		read(f);
		to[++cntot]=i;
		nxt[cntot]=begin[f];
		begin[f]=cntot;
	}
	for(int i=1;i<=n;++i)	read(val[i]);
	dfs(1);
	write(search(0,2e5*1e9));
	return 0;
}
```

</details>

### CF1093D Beautiful Graph - AC

ã€‚

<details>

```cpp
#include <cstdio>

namespace Fate
{
#define mod ( 998244353 )

typedef long long LL;

const int MAXN = 3e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, m, cnt, vis[MAXN], degin[MAXN], bla, whi;

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, degin[u] ), degin[u] = cnt; }

bool dfs ( const int u ) {
	for ( int i = degin[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( ~ vis[v] ) {
			if ( vis[u] == vis[v] )	return 0;
		}
		else {
			vis[v] = vis[u] ^ 1;
			if ( ! dfs ( v ) )	return 0;
		}
	}
	if ( vis[u] )	bla ++;
	else	whi ++;
	return 1;
}

LL Qkpow ( LL base, int indx ) {
	LL res = 1;
	for ( ; indx; indx >>= 1 ) {
		if ( indx & 1 )	res = res * base % mod;
		base = base * base % mod;
	}
	return res;
}

void Zero () {
	int onePun = rint ();
	while ( onePun -- > 0 ) {
		n = rint (), m = rint ();
		for ( int i = 1; i <= n; ++ i )	degin[i] = 0, vis[i] = -1;
		for ( int i = 1, u, v; i <= m; ++ i ) {
			u = rint (), v = rint ();
			makeEdge ( u, v ), makeEdge ( v, u );
		}
		LL ans = 1;
		bool flag = 0;
		for ( int i = 1; i <= n; ++ i ) {
			bla = whi = 0;
			if ( ~ vis[i] )	continue;
			vis[i] = 1;
			if ( ! dfs ( i ) ) {
				flag = 1;
				wint ( 0 ), putchar ( '\n' );
				break;
			}
			else	ans = ans * ( ( Qkpow ( 2, bla ) + Qkpow ( 2, whi ) ) % mod ) % mod;
		}
		if ( ! flag )	wint ( ans ), putchar ( '\n' );
	}
}
}

int main () { Fate :: Zero (); return 0; }
```

</details>

### CF1355E Restorer Distance

æœ‰ä¸€ä¸ªåŸºç¡€æƒ³æ³•ï¼Œå³ä¸€æ¬¡æ“ä½œä¸‰å¯ä»¥ç”¨ä¸€æ¬¡æ“ä½œä¸€åŠ ä¸Šä¸€æ¬¡æ“ä½œäºŒæ¥å®ç°ï¼Œç„¶åä»–åˆæ²¡è®©æˆ‘ä»¬æœ€å°åŒ–æ“ä½œæ¬¡æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»¤ $M=\min\{A+R,M\}$ã€‚

æ“ä½œçš„é¡ºåºå¹¶ä¸å½±å“ï¼Œæ‰€ä»¥ä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬å¯ä»¥å°†åŸæ•°ç»„æ’ä¸ªåºã€‚

æ„Ÿè§‰èŠ±è´¹æ˜¯ä¸€ä¸ªå•å³°ã€‚

ä¸‰åˆ†å§ã€‚

è¿‡äº†ã€‚

è‰ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MIN ( const _T x, const _T y ) { return x < y ? x : y; }

int n, cosA, cosR, cosM, a[MAXN];

LL calcPnt ( LL pnt ) {
	LL sumles = 0, summor = 0;
	for ( int i = 1; i <= n; ++ i ) {
		if ( a[i] < pnt )	sumles += pnt - a[i];
		else	summor += a[i] - pnt;
	}
	if ( sumles < summor )	return cosM * sumles + cosR * ( summor - sumles );
	else	return cosM * summor + cosA * ( sumles - summor );
}

LL solve ( LL l, LL r ) {
	while ( l + 1 < r ) {
		int onemid = l + ( r - l + 1 ) / 3;
		int anomid = r - ( r - l + 1 ) / 3;
		if ( calcPnt ( onemid ) > calcPnt ( anomid ) )	l = onemid;
		else	r = anomid;
	}
	return MIN ( calcPnt ( l ), calcPnt ( l + 1 ) );
}

int main () {
	n = rint (), cosA = rint (), cosR = rint (), cosM = rint ();
	cosM = MIN ( cosM, cosA + cosR );
	for ( int i = 1; i <= n; ++ i )	a[i] = rint ();
	wint ( solve ( 0, 2e9 ) );
	return 0;
}
```

</details>

### BalkanOI 2018 Day2 Parentrises

##### Subtask one

çœ‹è§æ‹¬å·å…ˆ $-1+1$ï¼Œèµ·å§‹æ—¶æ¯ä¸€ä¸ªæ‹¬å·å…ˆå‡è®¾æˆç»¿è‰²ã€‚

å…ˆä»å·¦å¾€å³æ‰«ï¼Œå¦‚æœæ­¤æ—¶å³æ‹¬å·çš„æ•°é‡å¤§äºäº†å·¦æ‹¬å·çš„æ•°é‡ï¼Œæˆ‘ä»¬å°±æŠŠåºåˆ—ä¸­æœ€å‰é¢çš„ä¸¤ä¸ªå³æ‹¬å·åˆ†åˆ«æŸ“æˆçº¢ã€è“è‰²ï¼Œä¸è¶³åˆ™æ— è§£ã€‚

åé¢æ‡’å¾—å†™äº†ã€‚

##### Subtask two

è€ƒè™‘ DPã€‚

æ•°æ®èŒƒå›´æ„Ÿè§‰åŒºé—´ DPã€‚

å¯¹ä¸èµ·æˆ‘æ²¡è¯»é¢˜ã€‚

é‡æ–°è€ƒè™‘ã€‚

ä¸ä¼šã€‚

ç®—äº†çœ‹é¢˜è§£ã€‚

è´´ä¸ªé“¾æ¥å§ï¼š[Here](https://www.cnblogs.com/klauralee/p/11283704.html)ã€‚

<details>

```cpp
#include <queue>
#include <cstdio>
#include <cstring>

using namespace std;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <='9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x < y ? y : x; }

int Strlen ( char * str ) {
	int res = 0;
	for ( ; * ( str ++ ) != '\0'; ++ res ) ;
	return res;
}

namespace Greedy {
const int MAXN = 1e6 + 5;

int n, ans[MAXN], pre[MAXN], suf[MAXN];
char str[MAXN];

char Trans ( const int x ) { return x == 0 ? 'G' : ( x == 1 ? 'B' : 'R' ); }
void solving () {
	queue<int> align;
	int lst = 0;
	for ( int i = 1; i <= n + 1; ++ i )	pre[i] = suf[i] = ans[i] = 0;
	for ( int i = 1; i <= n; ++ i ) {
		if ( str[i] == '(' )	pre[i] = pre[i - 1] + 1;
		else	pre[i] = pre[i - 1] - 1, align.push ( i );
		if ( pre[i] < 0 ) {
			pre[i] = 0;
			if ( align.size () < 2u )	return void ( printf ( "impossible\n" ) );
			ans[align.front ()] = 1, align.pop ();
			ans[align.front ()] = 2, align.pop ();
		}
		if ( ! pre[i] )	lst = i;
	}
	if ( pre[n] > 0 ) {
		for ( int i = n; i > lst; -- i ) {
			if ( str[i] == ')' )	suf[i] = suf[i + 1] + 1;
			else	suf[i] = suf[i + 1];
		}
		int tmp = pre[n] * 2;
		for ( int i = n; i > lst; -- i ) {
			if ( str[i] == '(' ) {
				if ( tmp & 1 )	ans[i] = 1;
				else	ans[i] = 2;
				if ( ( n - suf[i] - i + 2 ) / 2 > suf[i] )	return void ( printf ( "impossible\n" ) );
				tmp --;
				if ( ! tmp )	break;
			}
		}
		if ( tmp )	return void ( printf ( "impossible\n" ) );
	}
	for ( int i = 1; i <= n; ++ i )	putchar ( Trans ( ans[i] ) );
	putchar ( '\n' );
}

void solve () {
	int TC = rint ();
	while ( TC -- > 0 )	scanf ( "%s", str + 1 ), n = Strlen ( str + 1 ), solving ();
}
}

namespace Dynamic {
#define mod ( 1000000007 )
const int MAXN = 3e2 + 5;
int n, f[2][MAXN][MAXN * 2], ans[MAXN];

void preSave ( const int lim ) {
	f[1][0][0] = 1;
	for ( int i = 0; i <= lim; ++ i ) {
		memset ( f[i & 1], 0, sizeof ( f[i & 1] ) );
		for ( int j = 0; j <= i; ++ j ) {
			for ( int k = 0; k <= ( i << 1 ); ++ k ) {
				if ( ( i - j ) * 2 - j - k >= 0 )	( ans[i] += f[( i & 1 ) ^ 1][j][k] ) %= mod;
				if ( j * 2 - ( i - j ) - 1 >= 0 )	( f[i & 1][j][MAX ( k, ( ( i - j + 1 ) * 2 - j ) )] += f[( i & 1 ) ^ 1][j][k] ) %= mod;
				( f[i & 1][j + 1][MAX ( k, ( i - j ) * 2 - j - 1 )] += f[( i & 1 ) ^ 1][j][k] ) %= mod;
			}
		}
	}
}

void solve () {
	int TC = rint (); preSave ( 3e2 );
	while ( TC -- > 0 )	n = rint (), wint ( ans[n] ), putchar ( '\n' );
}
}

int main () {
	int subtaskID = rint ();
	if ( subtaskID == 1 )	Greedy :: solve ();
	else	Dynamic :: solve ();
	return 0;
}
```

</details>

### P7100 [w3R1] å›¢ - AC

å»ºè™šç‚¹ã€‚

<details>

```cpp
#include <queue>
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long LL;

const int MAXN = 1e6 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

struct GraphSet {
	int to, nx;
	LL wt;
	GraphSet ( int T = 0, int N = 0, LL W = 0 ) { to = T, nx = N, wt = W; }
} as[MAXN * 6];

struct PointSet {
	int pnt;
	LL wt;
	PointSet ( int P = 0, LL W = 0 ) { pnt = P, wt = W; }
	bool operator < ( const PointSet &other ) const { return wt > other.wt; }
};

int n, k, cnt, bgn[MAXN], vis[MAXN];
LL dis[MAXN];

void makeEdge ( const int u, const int v, const LL w ) { as[++ cnt] = GraphSet ( v, bgn[u], w ), bgn[u] = cnt; }

void calcSP ( const int S ) {
	memset ( dis, 0x3f, sizeof ( dis ) );
	for ( int i = 1; i <= n; ++ i )	dis[i] = 0x3f3f3f3f3f3f3f3fll;
	priority_queue<PointSet> align;
	dis[S] = 0, align.push ( PointSet ( S, dis[S] ) );
	while ( ! align.empty () ) {
		int u = align.top ().pnt;
		align.pop ();
		if ( vis[u] )	continue;
		vis[u] = 1;
		for ( int i = bgn[u]; i; i = as[i].nx ) {
			int v = as[i].to;
			LL w = as[i].wt;
			if ( dis[v] > dis[u] + w ) {
				dis[v] = dis[u] + w;
				align.push ( PointSet ( v, dis[v] ) );
			}
		}
	}
}

int main () {
	n = rint (), k = rint ();
	for ( int i = 1; i <= k; ++ i ) {
		int absS = rint ();
		for ( int j = 1; j <= absS; ++ j ) {
			int u = rint (), v = rint ();
			makeEdge ( u, n + i, v );
			makeEdge ( n + i, u, v );
		}
	}
	calcSP ( 1 );
	for ( int i = 1; i <= n; ++ i )	wint ( dis[i] ), putchar ( ' ' );
	return 0;
}
```

</details>

### CF280D k-Maximum Subsequence Sum - AC

åšæ³•å’Œ LOC25918 åŒç«¯é˜Ÿåˆ—xLISé—®é¢˜ ä¸€æ ·ã€‚

<details>

```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5;

char buf[1 << 21], * p1 = buf, * p2 = buf;
#define bufchar ( p1 == p2 && ( p2 = ( p1 = buf ) + fread ( buf, 1, 1 << 21, stdin ), p1 == p2 ) ? EOF : * p1 ++ )

int rint () {
	int x = 0, f = 1; char c = bufchar;
	for ( ; c < '0' || c > '9'; c = bufchar )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = bufchar )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x < y ? y : x; }
template<typename _T> void swapp ( _T &x, _T &y ) { _T w = x; x = y; y = w; }

struct SegmentTree {
	LL val, dat, p, s;
	int l, r, pl, pr, sl, sr;
	SegmentTree ( LL V = 0, LL D = 0, LL P = 0, LL S = 0,
			int L = 0, int R = 0, int Pl = 0, int Pr = 0, int Sl = 0, int Sr = 0 ) {
				val = V, dat = D, p = P, s = S, l = L, r = R, pl = Pl, pr = Pr, sl = Sl, sr = Sr; }
} nodes[MAXN * 4][2];

int n, m, a[MAXN], opl[MAXN], opr[MAXN];
bool tag[MAXN * 4];

SegmentTree merge ( const SegmentTree lch, const SegmentTree rch ) {
	SegmentTree ret;
	ret.val = lch.val + rch.val;
	ret.p = MAX ( lch.p, lch.val + rch.p );
	if ( ret.p == lch.p )	ret.pl = lch.pl, ret.pr = lch.pr;
	else	ret.pl = lch.pl, ret.pr = rch.pr;
	ret.s = MAX ( rch.s, rch.val + lch.s );
	if ( ret.s == rch.s )	ret.sl = rch.sl, ret.sr = rch.sr;
	else	ret.sl = lch.sl, ret.sr = rch.sr;
	ret.dat = MAX ( lch.s + rch.p, MAX ( lch.dat, rch.dat ) );
	if ( ret.dat == lch.dat )	ret.l = lch.l, ret.r = lch.r;
	else if ( ret.dat == rch.dat )	ret.l = rch.l, ret.r = rch.r;
	else	ret.l = lch.sl, ret.r = rch.pr;
	return ret;
}

void Upt ( const int x ) {
	nodes[x][0] = merge ( nodes[x << 1][0], nodes[x << 1 | 1][0] );
	nodes[x][1] = merge ( nodes[x << 1][1], nodes[x << 1 | 1][1] );
}

void Spr ( const int x ) {
	if ( ! tag[x] )	return;
	swapp ( nodes[x << 1][0], nodes[x << 1][1] );
	swapp ( nodes[x << 1 | 1][0], nodes[x << 1 | 1][1] );
	tag[x << 1] ^= 1, tag[x << 1 | 1] ^= 1, tag[x] = 0;
}

void build ( const int x, const int l, const int r ) {
	if ( l == r ) {
		nodes[x][0] = SegmentTree ( a[l], a[l], a[l], a[l], l, l, l, l, l, l );
		nodes[x][1] = SegmentTree ( -a[l], -a[l], -a[l], -a[l], l, l, l, l, l, l );
		return;
	}
	int mid = ( l + r ) >> 1;
	build ( x << 1, l, mid );
	build ( x << 1 | 1, mid + 1, r );
	Upt ( x );
}

void modifyRV ( const int x, const int l, const int r, const int segL, const int segR ) {
	if ( l > segR || r < segL )	return;
	if ( l >= segL && r <= segR ) {
		swapp ( nodes[x][0], nodes[x][1] );
		tag[x] ^= 1;
		return;
	}
	int mid = ( l + r ) >> 1;
	Spr ( x );
	modifyRV ( x << 1, l, mid, segL, segR );
	modifyRV ( x << 1 | 1, mid + 1, r, segL, segR );
	Upt ( x );
}

void modifyPT ( const int x, const int l, const int r, const int segP, const int segW ) {
	if ( l == r ) {
		nodes[x][0] = SegmentTree ( segW, segW, segW, segW, l, l, l, l, l, l );
		nodes[x][1] = SegmentTree ( -segW, -segW, -segW, -segW, l, l, l, l, l, l );
		return;
	}
	int mid = ( l + r ) >> 1;
	Spr ( x );
	if ( mid >= segP )	modifyPT ( x << 1, l, mid, segP, segW );
	else	modifyPT ( x << 1 | 1, mid + 1, r, segP, segW );
	Upt ( x );
}

SegmentTree query ( const int x, const int l, const int r, const int segL, const int segR ) {
	if ( l > segR || r < segL )	return SegmentTree ();
	if ( l >= segL && r <= segR )	return nodes[x][0];
	int mid = ( l + r ) >> 1;
	Spr ( x );
	return merge ( query ( x << 1, l, mid, segL, segR ), query ( x << 1 | 1, mid + 1, r, segL, segR ) );
}

int main () {
	n = rint ();
	for ( int i = 1; i <= n; ++ i )	a[i] = rint ();
	build ( 1, 1, n );
	m = rint ();
	while ( m -- > 0 ) {
		int opt = rint ();
		if ( ! opt ) {
			int pos = rint (), val = rint ();
			modifyPT ( 1, 1, n, pos, val );
		}
		else {
			int l = rint (), r = rint (), k = rint (), top = 0;
			LL res = 0;
			while ( k -- > 0 ) {
				SegmentTree ret = query ( 1, 1, n, l, r );
				if ( ret.dat < 0 )	break;
				modifyRV ( 1, 1, n, ret.l, ret.r );
				top ++;
				opl[top] = ret.l, opr[top] = ret.r;
				res += ret.dat;
			} 
			for ( ; top; top -- )	modifyRV ( 1, 1, n, opl[top], opr[top] );
			wint ( res ), putchar ( '\n' );
		}
	}
	return 0;
}
```

</details>

### CF120F Spiders

æŠŠæ¯æ£µæ ‘çš„ç›´å¾„æ‹¼åœ¨ä¸€èµ·ã€‚

<details>

```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 1e2 + 5;

int rint () {
	int x = 0, f = 1; char c = getchar ();
	for ( ; c < '0' || c > '9'; c = getchar () )	f = c == '-' ? -1 : f;
	for ( ; c >= '0' && c <= '9'; c = getchar () )	x = ( x << 3 ) + ( x << 1 ) + ( c & 15 );
	return x * f;
}

template<typename _T>
void wint ( _T x ) {
	if ( x < 0 )	putchar ( '-' ), x = ~ x + 1;
	if ( x > 9 )	wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

template<typename _T> _T MAX ( const _T x, const _T y ) { return x < y ? y : x; }

struct GraphSet {
	int to, nx;
	GraphSet ( int T = 0, int N = 0 ) { to = T, nx = N; }
} as[MAXN * 2];

int n, f[MAXN][2], bgn[MAXN], cnt;

void makeEdge ( const int u, const int v ) { as[++ cnt] = GraphSet ( v, bgn[u] ), bgn[u] = cnt; }

void dfs ( const int u, const int lst ) {
	int oneval = 0, anoval = 0;
	for ( int i = bgn[u]; i; i = as[i].nx ) {
		int v = as[i].to;
		if ( v == lst )	continue;
		dfs ( v, u );
		f[u][0] = MAX ( f[u][0], f[v][0] + 1 );
		if ( f[v][0] + 1 > oneval )	anoval = oneval, oneval = f[v][0] + 1;
		else if ( f[v][0] + 1 > anoval )	anoval = f[v][0] + 1;
	}
	f[u][1] = MAX ( oneval + anoval, MAX ( oneval, anoval ) );
}

int main () {
	freopen ( "input.txt", "r", stdin );
	freopen ( "output.txt", "w", stdout );
	n = rint ();
	int ans = 0;
	for ( int i = 1; i <= n; ++ i ) {
		int nod = rint ();
		for ( int i = 1; i < nod; ++ i ) {
			int u = rint (), v = rint ();
			makeEdge ( u, v ), makeEdge ( v, u );
		}
		dfs ( 1, 0 );
		int ret = 0;
		for ( int i = 1; i <= nod; ++ i )	ret = MAX ( ret, f[i][1] );
		ans += ret;
		for ( int i = 1; i <= nod; ++ i )	bgn[i] = f[i][0] = f[i][1] = 0;
		cnt = 0;
	}
	wint ( ans ), putchar ( '\n' );
	return 0;
}
```

</details>

### P6274 [eJOI2017]å…­ - IP

æœ€å¤šä¸€ä¸ªæ•°ä¸ $x$ ä¸äº’è´¨ï¼Œå…¶ä»–æ•°éƒ½ä¸ $x$ äº’è´¨ï¼Œè¿™æ ·è¯»èµ·æ¥èˆ’æœä¸€ç‚¹ã€‚

å¤§æ¦‚èƒ½çŒœå‡ºæ¥æ˜¯çŠ¶å‹ï¼Œè®¾ $N$ çš„è´¨å› æ•°é›†åˆä¸º $S^{(N)}$ï¼Œæœ‰ $|S^{(N)}|\le 6$ã€‚

åŸºæœ¬æƒ³æ³•ï¼Œè®¾ $f_{S}$ è¡¨ç¤ºå½“å‰åŠ å…¥çš„æ•°ï¼ˆè®¾ä¸º $x$ï¼‰ä¸º $S^{(N)}$ ä¸­çš„æ•°çš„å€æ•°æƒ…å†µã€‚å¦‚æœ $S^{N}_{i}\mid x$ï¼Œåˆ™æœ‰ $S_{i}=1$ï¼Œå¦åˆ™ä¸º $0$ã€‚

<details>

```cpp
// å¯‚å¯
```

</details>